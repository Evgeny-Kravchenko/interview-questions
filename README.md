# interview-questions

The repository includes interview questions for a front-end developer

## Questions

### HTML

1. [What does `doctype` do](#html-doctype)
2. [How do you serve a page with content in multiple languages?](#html-lang)
3. [What kind of things must you be wary of when designing or developing for multilingual sites?](#html-multi-lang)
4. [What are `data-` attributes good for?](#html-data-attr)
5. [Consider HTML5 as an open web platform. What are the building blocks of HTML5?](#html-html5)
6. [Describe the difference between a cookie, sessionStorage and localStorage](#html-csl)
7. [Describe the difference between `<script>`, `<script async>` and `<script defer>`.](#html-async-defer)
8. [Why is it generally a good idea to position CSS ```<link>```s between ```<head></head>``` and JS ```<script>```s just before ```</body>```? Do you know any exceptions?](#html-css-js)
9. [What is progressive rendering?](#html-progressive-rendering)
10. [What is an image map?](#html-map)
11. [What is the canvas element in HTML5?](#html-canvas)
12. [What is SVG?](#html-svg)
13. [What is the difference between progress and meter tag?](#html-progress-meter)
14. [What is the use of figure tag in HTML 5?](#html-figure)
15. [What is the use of figcaption tag in HTML 5?](#html-figcaption)
16. [What is the use of details and summary tag?](#html-details-summary)
17. [What is datalist tag?](#html-datalist)
18. [If I do not put <!DOCTYPE html> will HTML 5 work?](#html-not-doctype)
19. [What is the use of the required attribute in HTML5?](#html-required)
20. [Do all character entities display properly on all systems?](#html-character)
21. [How do you change the number type in the middle of a list?](#html-change-number-list)
22. [How do you create multicolored text in a webpage?](#html-multicolored)
23. [What is the advantage of grouping several checkboxes together?](#html-checkboxes-group)
24. [What are applets?](#html-applets)
25. [Is it possible to set specific colors for table borders?](#html-table-color)
26. [What happens if the list-style-type property is used on a non-list element like a paragraph?](#html-non-list)
27. [What are the new FORM elements which are available in HTML5?](#html-newtags-form)
28. [Tell me two benefits of HTML5 Web Storage](#html-benefits-webstorage)
29. [What is the Application Cache in HTML5 and why it is used?](#html-cache)

### CSS

1. [What is CSS?](#css-is)
2. [Name all the modules which are used in the current version of CSS.](#css-modules)
3. [Distinguish between CSS2 and CSS3.](#css-distinguish)
4. [Cite different types of CSS.](#css-different-types)
5. [Why is the external style sheet useful?](#css-useful-external)
6. [Define CSS image scripts.](#css-image-scripts)
7. [Explain the term Responsive web design.](#css-responsive)
8. [What are CSS counters?](#css-counters)
9. [What is CSS specificity?](#css-specifity)
10. [How can we calculate specificity?](#css-calculate-specifity)
11. [How do we make a rounded corner by using CSS?](#css-rounded-corners)
12. [How will you add border images to an HTML element?](#css-border-image)
13. [What is CSS flexbox?](#css-flex)
14. [Write all the properties of the flexbox.](#css-flex-property)
15. [What is the difference between padding and margin?](#css-mp)
16. [What is the use of the Box Model in CSS?](#css-box-model)
17. [What is a CSS pseudo-class?](#css-pseudo-class)
18. [Explain the concept of pseudo-elements in CSS.](#css-pseudo-elements)
19. [What is CSS opacity?](#css-opacity)
20. [Write all the position states used in CSS.](#css-position-states)
21. [What are the differences between relative and absolute in CSS?](#css-rel-abs-diff)
22. [Define ‘important’ declarations used in CSS.](#css-important)
23. [Define different cascading methods that can be used inside the cascading order.](#css-cascading)
24. [Differentiate between inline and block element.](#css-inline-block)
25. [How is the concept of inheritance applied in CSS?](#css-inherit)
26. [Explain universal selector.](#css-universal-selector)
27. [Name the property used to specify the background color of an element.](#css-background-color)
28. [Name the property for controlling the image repetition of the background.](#css-repeat)
29. [Name the property for controlling the image position in the background.](#css-image-position)
30. [Name the property for controlling the image scroll in the background.](#css-background-attachment)
31. [What are the benefits of CSS sprites?](#css-sprites)
32. [What are attributes and how are they used?](#css-attr)
33. [What’s your preferred way of sizing fonts?](#css-fonts)
34. [What are web safe fonts and fallback fonts?](#css-font-safe)
35. [How would you use media queries in a mobile-first approach?](#css-how-use-media)
36. [Have you used Flexbox & CSS Grid before? What are the differences between them?](#css-flex-grid)

### Javascript

1. [What is JavaScript?](#js-what-is)
2. [What are JavaScript Data Types?](#js-types)
3. [What is the use of isNaN function?](#js-isNaN)
4. [What is negative infinity?](#js-infinity)
5. [What are global variables? How are these variable declared and what are the problems associated with using them?](#js-global-variables)
6. [What's the difference between undefined and null?](#js-difference-undefined-null)
7. [What does the && operator do?](#js-&&)
8. [What does the || operator do?](#js-||)
9. [Is using the + or unary plus operator the fastest way in converting a string to a number?](#js-+)
10. [What is the DOM?](#js-what-is-dom)
11. [What is Event Propagation?](#js-event-propagation)
12. [What's Event Bubbling?](#js-event-bubbling)
13. [What's Event Capturing?](#js-event-capturing)
14. [What's the difference between event.preventDefault() and event.stopPropagation() methods?](#js-diff-prevent-propagation)
15. [How to know if the event.preventDefault() method was used in an element?](#js-preventDef-known-use)
16. [Why does this code obj.someprop.x throw an error?](#js-error-obj-property)
17. [What is event.target ?](#js-event-target)
18. [What is event.currentTarget?](#js-current-target)
19. [What's the difference between == and ===?](#js-diff-comparing)
20. [Why does it return false when comparing two similar objects in JavaScript?](#js-comparing-two-obj)
21. [What does the !! operator do?](#js-oper!!-do)
22. [How to evaluate multiple expressions in one line?](#js-one-line)
23. [What is Hoisting?](#js-hoisting)
24. [What is Scope?](#js-scope)
25. [What are Closures?](#js-closures)
26. [What are the falsy values in JavaScript?](#js-falsy-values)
27. [How to check if a value is falsy?](#js-check-falsy)
28. [What does "use strict" do?](#js-use-strict)
29. [What's the value of this in JavaScript?](#js-this)
30. [What is the prototype of an object?](#js-prototype)
31. [What is an IIFE, what is the use of it?](#js-iive)
32. [What is the use ```Function.prototype.apply``` method?](#js-apply)
33. [What is the use ```Function.prototype.call``` method?](#js-call)
34. [What's the difference between ```Function.prototype.apply``` and ```Function.prototype.call```?](#js-diff-apply-call)
35. [What is the usage of Function.prototype.bind?](#js-bind)
36. [What is Functional Programming and what are the features of JavaScript that makes it a candidate as a functional language?](#js-functional-programing)
37. [What are Higher Order Functions?](#js-high-order-functions)
38. [Why are functions called First-class Objects?](#js-why-func-call-obj)
39. [Implement the Array.prototype.map method by hand.](#js-impl-map)
40. [Implement the Array.prototype.filter method by hand.](#js-impl-filter)
41. [Implement the Array.prototype.reduce method by hand.](#js-impl-reduce)
42. [What is the arguments object?](#js-arg)
43. [How to create an object without a prototype?](#js-create-obj-without-prot)
44. [Why does b in this code become a global variable when you call this function?](#js-44)
45. [What is ECMAScript?](#js-what-ECMA)
46. [What are the new features in ES6 or ECMAScript 2015?](#js-new-features-es6)
47. [What's the difference between var, let and const keywords?](#js-var-let-const)
48. [What are Arrow functions?](#js-arrow-func)
49. [What are Classes?](#js-classes)
50. [What are Template Literals?](#js-templ-literals)
51. [What are ES6 Modules?](#js-es6-modules)
52. [What is the Set object and how does it work?](#js-set-object)
53. [What is a Callback function?](#js-callback)
54. [What are Promises?](#js-promises)
55. [What is async/await and How does it work?](#js-async-await)
56. [What's the difference between Spread operator and Rest operator?](#js-spred-rest)
57. [What are Default Parameters?](#js-default-parameters)
58. [What are Wrapper Objects?](#js-wrapper-objects)
59. [What is the difference between Implicit and Explicit Coercion?](#js-diff-impl-expl)
61. [How to check if a value is an Array?](#js-check-is-array)
62. [How to check if a certain property exists in an object?](#js-check-property-exist)
63. [What is AJAX?](#js-ajax)
64. [What are the ways of making objects in JavaScript?](#js-create-object)
65. [What's the difference between Object.seal and Object.freeze methods?](#js-diff-freeze-seal)
66. [What's the difference between the in operator and the hasOwnProperty method in objects?](#js-diff-in-hasOwnProperty)
67. [What are the ways to deal with Asynchronous Code in JavasScript?](#js-asynch)
68. [What's the difference between a function expression and function declaration?](#js-expr-decl)
69. [How many ways can a function be invoked?](#js-ways-invoke-func)
70. [What is memoization and what's the use it?](#js-memoization)
71. [Implement a memoization helper function.](#js-impl-memoization)
72. [Why does typeof null return object? How to check if a value is null?](#js-null-obj)
73. [What does the new keyword do?](#js-new)

### Javascript tasks

1. [What is a potential pitfall with using ```typeof bar === "object"``` to determine if bar is an object? How can this pitfall be avoided?](#js-task-1)
2. [What will the code below output to the console and why?](#js-task-2)

        (function(){
          var a = b = 3;
        })();
        
        console.log("a defined? " + (typeof a !== 'undefined'));
        console.log("b defined? " + (typeof b !== 'undefined'));

3. [What will the code below output to the console and why?](#js-task-3)

        var myObject = {
            foo: "bar",
            func: function() {
                var self = this;
                console.log("outer func:  this.foo = " + this.foo);
                console.log("outer func:  self.foo = " + self.foo);
                (function() {
                    console.log("inner func:  this.foo = " + this.foo);
                    console.log("inner func:  self.foo = " + self.foo);
                }());
            }
        };
        myObject.func();

4. [Consider the two functions below. Will they both return the same thing? Why or why not?](#js-task-4)

        function foo1()
                {
                  return {
                      bar: "hello"
                  };
                }
                
                function foo2()
                {
                  return
                  {
                      bar: "hello"
                  };
        }

5. [What will the code below output? Explain your answer.](#js-task-5)

        console.log(0.1 + 0.2);
        console.log(0.1 + 0.2 == 0.3);

6. [Discuss possible ways to write a function ```isInteger(x)``` that determines if ```x``` is an integer.](#js-task-6)
7. [In what order will the numbers 1-4 be logged to the console when the code below is executed? Why?](#js-task-7)

        (function() {
            console.log(1); 
            setTimeout(function(){console.log(2)}, 1000); 
            setTimeout(function(){console.log(3)}, 0); 
            console.log(4);
        })();

8. [Write a simple function (less than 160 characters) that returns a boolean indicating whether or not a string is a palindrome.](#js-task-8)
9. [Write a sum method which will work properly when invoked using either syntax below.](#js-task-9)
10. [Consider the following code snippet:](#js-task-10)

        for (var i = 0; i < 5; i++) {
          var btn = document.createElement('button');
          btn.appendChild(document.createTextNode('Button ' + i));
          btn.addEventListener('click', function(){ console.log(i); });
          document.body.appendChild(btn);
        }
        
    * What gets logged to the console when the user clicks on “Button 4” and why?
    * Provide one or more alternate implementations that will work as expected.
    
11. [Assuming d is an “empty” object in scope, say:](#js-task-11)

        var d = {};
    
    …what is accomplished using the following code?
    
        [ 'zebra', 'horse' ].forEach(function(k) {
            d[k] = undefined;
        });
        
12. [What will the code below output to the console and why?](#js-task-12)

    var arr1 = "john".split('');
    var arr2 = arr1.reverse();
    var arr3 = "jones".split('');
    arr2.push(arr3);
    console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));
    console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1));

13. [What will the code below output to the console and why ?](#js-task-13)

    console.log(1 +  "2" + "2");
    console.log(1 +  +"2" + "2");
    console.log(1 +  -"1" + "2");
    console.log(+"1" +  "1" + "2");
    console.log( "A" - "B" + "2");
    console.log( "A" - "B" + 2);

14. [The following recursive code will cause a stack overflow if the array list is too large. How can you fix this and still retain the recursive pattern?](#js-task-14)

        var list = readHugeList();
        
        var nextListItem = function() {
            var item = list.pop();
        
            if (item) {
                // process the list item...
                nextListItem();
            }
        };
    
15. [What will be the output of the following code:](#js-task-15)

        for (var i = 0; i < 5; i++) {
        	setTimeout(function() { console.log(i); }, i * 1000 );
        }

16. [What would the following lines of code output to the console?](#js-task-16)

        console.log("0 || 1 = "+(0 || 1));
        console.log("1 || 2 = "+(1 || 2));
        console.log("0 && 1 = "+(0 && 1));
        console.log("1 && 2 = "+(1 && 2));

17. [What will be the output when the following code is executed? Explain.](#js-task-17)

        console.log(false == '0')
        console.log(false === '0')

18. [What is the output out of the following code? Explain your answer.](#js-task-18)

                var a={},
                    b={key:'b'},
                    c={key:'c'};
                
                a[b]=123;
                a[c]=456;
                
                console.log(a[b]);

19. [What will the following code output to the console:](#js-task-19)

        console.log((function f(n){return ((n > 1) ? n * f(n-1) : n)})(10));

20. [](#js-task-20)
21. [](#js-task-21)
22. [](#js-task-22)
23. [](#js-task-23)
24. [](#js-task-24)
25. [](#js-task-25)


## Answers

### HTML

1. <a id="html-doctype">What does a `doctype` do?</a>

   A DOCTYPE is a required preamble.

   DOCTYPEs are required for legacy reasons. When omitted, browsers tend to use a different rendering mode that is incompatible with some specifications. Including the DOCTYPE in a document ensures that the browser makes a best-effort attempt at following the relevant specifications.

2. <a id="html-lang">How do you serve a page with content in multiple languages?</a>

   When an HTTP request is made to the server, the browser usually sends the preferred language information in the Accept-Language header. The server can use this information to return the version of the document in the appropriate language, if possible. In the returned HTML document, the `lang` attribute of the `<html>` tag must be specified, for example, `<html lang = "en">`.

3. <a id="html-multi-lang">What kind of things must you be wary of when designing or developing for multilingual sites?</a>

   - Redirect users to the site version in their language.
   - Limiting the length of words and sentences.
   - Format dates and currencies.
   - Different directions of reading.

4. <a id="html-data-attr">What are `data-` attributes good for?</a>

   HTML5 is designed with extensibility in mind for data that should be associated with a particular element but need not have any defined meaning. data-\* attributes allow us to store extra information on standard, semantic HTML elements without other hacks such as non-standard attributes, extra properties on DOM, or Node.setUserData().

5. <a id="html-html5">Consider HTML5 as an open web platform. What are the building blocks of HTML5?</a>

   - Semantics: allowing you to describe more precisely what your content is.
   - Connectivity: allowing you to communicate with the server in new and innovative ways.
   - Offline and storage: allowing webpages to store data on the client-side locally and operate offline more efficiently.
   - Multimedia: making video and audio first-class citizens in the Open Web.
   - 2D/3D graphics and effects: allowing a much more diverse range of presentation options.
   - Performance and integration: providing greater speed optimization and better usage of computer hardware.
   - Device access: allowing for the usage of various input and output devices.
   - Styling: letting authors write more sophisticated themes.

6. <a id="html-csl">Describe the difference between a cookie, sessionStorage and localStorage?</a>

   ##### Local Storage

   - Stores data with no expiration date, and gets cleared only through JavaScript, or clearing the Browser cache / Locally Stored Data
   - Storage limit is the maximum amongst the three (10 mb)

   ##### Session storage

   - The sessionStorage object stores data only for a session, meaning that the data is stored until the browser (or tab) is closed.
   - Data is never transferred to the server.
   - Storage limit is larger than a cookie (at least 5MB).

   ##### Cookie

   - Stores data that has to be sent back to the server with subsequent requests. Its expiration varies based on the type and the expiration duration can be set from either server-side or client-side (normally from server-side).
   - Cookies are primarily for server-side reading (can also be read on client-side), localStorage and sessionStorage can only be read on client-side.
   - Size must be less than 4KB.
   - Cookies can be made secure by setting the httpOnly flag as true for that cookie. This prevents client-side access to that cookie.
   
7. <a id="html-async-defer">Describe the difference between `<script>`, `<script async>` and `<script defer>`.</a>

    - without attribute
    ![without attribute](./images/without-attribute.png "without attribute")
    
        A regular ```<script>``` tag will block rendering of the page, and the page will not continue to load until the script finishes.
    
    - async attrubute
    ![async attribute](./images/async-attribute.png "async attribute")
    
        ```<script async>``` will run the script asynchronously, meaning that it will not block rendering, but will run as soon as the script is available. This is usually intended for CDN files, or other such files, which do not change the page structure.
    
    - defer attribute
    ![defer attribute](./images/defer-attribute.png "defer attribute")
    
        ```<script defer>``` will defer the script to run after the page is done parsing and before an onload event.
    
8. <a id="html-css-js">Why is it generally a good idea to position CSS ```<link>```s between ```<head></head>``` and JS ```<script>```s just before ```</body>```? Do you know any exceptions?</a>

   The need to place <link> tags inside the site header is described in the specification. The problem with placing style sheets at the bottom of the page is that this order prevents progressive page loading in many browsers. Some browsers block page loading to avoid redrawing an element if its styles change. All this time the user will stare at the white screen. This browser behavior prevents flickering or rendering of non-stylized elements.
   
   The ```<script>``` tags block HTML rendering while they are being downloaded and executed. Downloading scripts at the end allows you to parse and show the user all the HTML first.
   
9.  <a id="html-progressive-rendering">What is progressive rendering?</a>

    Progressive rendering is the name given to techniques used to render content for display as quickly as possible.
    
    It used to be much more prevalent in the days before broadband internet but it's still useful in modern development as mobile data connections are becoming increasingly popular (and unreliable!)
    
    Examples of such techniques :
    
    - Lazy loading of images where (typically) some javascript will load an image when it comes into the browsers viewport instead of loading all images at page load.
    
    - Prioritizing visible content (or above the fold rendering) where you include only the minimum css/content/scripts necessary for the amount of page that would be rendered in the users browser first to display as quickly as possible, you can then use deferred javascript (domready/load) to load in other resources and content.
 
10. <a id='html-map'>What is an image map?</a>

    Image map facilitates you to link many different web pages using a single image. It is represented by <map> tag. You can define shapes in images that you want to make part of an image mapping.
    
11. <a id='html-canvas'>What is the canvas element in HTML5?</a>

    The <canvas> element is a container that is used to draw graphics on the web page using scripting language like JavaScript. It allows for dynamic and scriptable rendering of 2D shapes and bitmap images. There are several methods in canvas to draw paths, boxes, circles, text and add images.
    
12. <a id="html-svg">What is SVG?</a>

    HTML SVG is used to describe the two-dimensional vector and vector/raster graphics. SVG images and their behaviors are defined in XML text files. So as XML files, you can create and edit an SVG image with the text editor. It is mostly used for vector type diagrams like pie charts, 2-Dimensional graphs in an X, Y coordinate system.
    
13. <a id="html-progress-meter">What is the difference between progress and meter tag?</a>

    The progress tag is used to represent the progress of the task only while the meter tag is used to measure data within a given range.
    
14. <a id="html-figure">What is the use of figure tag in HTML 5?</a>
    
    The figure tag is used to add a photo in the document on the web page. It is used to handle the group of diagrams, photos, code listing with some embedded content.
    
15. <a id="html-figcaption">What is the use of figcaption tag in HTML 5?</a>

    The ```<figcaption>``` element is used to provide a caption to an image. It is an optional tag and can appear before or after the content within the <figure> tag. The ```<figcaption>``` element is used with ```<figure>``` element and it can be placed as the first or last child of the ```<figure>``` element.
    
16. <a id="html-details-summary">What is the use of details and summary tag?</a>

    The details tag is used to specify some additional details on the web page. It can be viewed or hidden on demand. The summary tag is used with details tag.
    
17. <a id="html-datalist">What is datalist tag?</a>

    The HTML 5 datalist tag provides an autocomplete feature on the form element. It facilitates users to choose the predefined options to the users to select data.
    
18. <a id="html-not-doctype">If I do not put ```<!DOCTYPE html>``` will HTML 5 work?</a>

    No, the browser will not be able to identify that it is an HTML document and HTML 5 tags do not function properly.
    
19. <a id="html-required">What is the use of the required attribute in HTML5?</a>

    It forces a user to fill text on the text field or text area before submitting the form. It is used for form validation.
    
20. <a id="html-character">Do all character entities display properly on all systems?</a>

    No, there are some character entities that cannot be displayed when the operating system that the browser is running on does not support the characters. When that happens, these characters are displayed as boxes.
    
21. <a id="html-change-number-list">How do you change the number type in the middle of a list?</a>

    The ```<li>``` tag includes two attributes – type and value. The type attribute can be used to change the numbering type for any list item. The value attribute can change the number index.
    
22. <a id="html-multicolored">How do you create multicolored text in a webpage?</a>

    To create text with different colors, use the ```<font color=”color”>…</font>``` tags for every character that you want to apply color. You can use this tag combination as many times as needed, surrounding a single character or an entire word.
    
23. <a id="html-checkboxes-group">What is the advantage of grouping several checkboxes together?</a>

    Although checkboxes don’t affect one another, grouping checkboxes together help to organize them. Checkbox buttons can have their name and do not need to belong to a group. A single web page can have many different groups of checkboxes.
    
24. <a id="html-applets">What are applets?</a>

    Applets are small programs that can be embedded within web pages to perform some specific functionality, such as computations, animations, and information processing. Applets are written using the Java language.
    
25. <a id="html-table-color">Is it possible to set specific colors for table borders?</a>

    You can specify a border color using style sheets, but the colors for a table that does not use style sheets will be the same as the text color.
    
26. <a id="html-non-list">What happens if the list-style-type property is used on a non-list element like a paragraph?</a>

    If the list-style-type property is used on a non-list element like a paragraph, the property will be ignored and do not affect the paragraph.
    
27. <a id="html-newtags-form">What are the new FORM elements which are available in HTML5?</a>

    The new Form elements in HTML5 offers much better functionality than the earlier versions.
    
    The tags given provided to carry out these functions are:
    
        <datalist> – This tag is use to specify a list of options for input controls.
        <keygen> – This tag represents a key-pair generator field.
        <output> – It represents the result of any scripting calculation.
        
28. <a id="html-benefits-webstorage">Tell me two benefits of HTML5 Web Storage</a>

    Two main benefits of HTML5 Web Storage:
    
    * It can store up to 10 MB data which is certainly more than what cookies have.
    
    * Web storage data cannot be transferred with the HTTP request. It helps to increase the performance of the application.
    
29. <a id="html-cache">What is the Application Cache in HTML5 and why it is used?</a>

    The Application Cache concept means that a web application is cached. It can be accessible without the need for internet connection.
    
    Some advantages of Application Cache:
    
        - Offline browsing – Web users can also use the application when they are offline.
        - Speed – Cached resources load quicker.
        - Reduce the server load – The web browser will only download updated resources from the server.
        
### CSS

1. <a id="css-is">What is CSS?</a>

    CSS outlines the style of an HTML webpage. It is a language by which we can set the behavior of an HTML webpage. It describes how the HTML content will be shown on screen.
    
2. <a id="css-modules">Name all the modules which are used in the current version of CSS.</a>

    There are several modules in CSS as stated below:
    
        - Selectors
        - Box model
        - Background and borders
        - Text effects
        - 2D/3D transformations
        - Animations
        - Multiple Column layout
        - User interface
        
3. <a id="css-distinguish"> Distinguish between CSS2 and CSS3.</a>
        
    The differences between CSS2 and CSS3 are as follows:
    
        - CSS3 is divided into two various sections which are called a module. Whereas in CSS2 everything accedes into a single document with all the information in it.
        - CSS3 modules are supported almost on every browser and on the other hand modules of CSS and CSS2 are not supported in every browser.
        - In CSS3, we will find that many graphics related characteristics have been introduced like Border-radius or box-shadow, flexbox.
        - In CSS3, a user can precise multiple background images on a webpage by using properties like background-image, background-position, and background-repeat styles.
        
4. <a id="css-different-types">Cite different types of CSS.</a>

    There are three types of CSS as mentioned below:
    
        - External: These are written in separate files.
        - Internal: These are cited at the top of the web page code document.
        - Inline: These are written right next to the text.
        
5. <a id="css-useful-external">Why is the external style sheet useful?</a>

    External style sheet is very useful as we write all the styling codes in a single file and it can be used anywhere by just referring to the link of that external style sheet file.
    
6. <a id="css-image-scripts">Define CSS image scripts.</a>

    CSS image scripts are a group of images that are placed into one image. It reduces the load time and request number to the server while projecting multiple images into a single web page.
 
7. <a id="css-responsive">Explain the term Responsive web design.</a>

    It is a method in which we design and develop a web page according to the user activities and conditions which are based on various components like the size of the screen, portability of the web page on the different devices, etc. It is done by using different flexible layouts and grids.
    
8. <a id="css-counters">What are CSS counters?</a>
    
    CSS counters are variables that can be incremented by rules of CSS that inspector track how many times the variable has been used.
    
9. <a id="css-specifity">What is CSS specificity?</a>

    CSS specificity is a score or rank that decides which style declaration has to be used to an element. (*) this universal selector has low specificity while ID selectors have high specificity.
    
10. <a id="css-calculate-specifity">How can we calculate specificity?</a>

    To calculate specificity we will start with 0, then we have to add 1000 for each ID and we have to add 10 to the attributes, classes or pseudo-classes with each element name or pseudo-element and later we have to add 1 to them.
    
11. <a id="css-rounded-corners">How do we make a rounded corner by using CSS?</a>

    We can make a rounded corner by using the property “border-radius”. We can apply this property to any element.
        
12. <a id="css-border-image">How will you add border images to an HTML element?</a>

    We can set the image to be used as the border-image alongside an element by using the property of CSS “border-image”.
    
13. <a id="css-flex">What is CSS flexbox?</a>

    It allows you to design a flexible responsive layout structure without using any float or positioning property of CSS. To use CSS flexbox you need to define a flex container initially.
    
14. <a id="css-flex-property">Write all the properties of the flexbox.</a>

    There are several properties of the flexbox that are used in the HTML webpage.
    
    They are:
    
        - flex-direction
        - flex-wrap
        - flex-flow
        - justify-content
        - align-items
        - align-content
        
15. <a id="css-mp">What is the difference between padding and margin?</a>

    In CSS, the margin is the property by which we can create space around elements. In CSS, padding is the property by which we can generate space around an element’s content as well as inside any known border.
    
16. <a id="css-box-model">What is the use of the Box Model in CSS?</a>

    In CSS, the box model is a box that binds all the HTML elements and it includes features like margins, border, padding, and the actual content.

17. <a id="css-pseudo-class">What is a CSS pseudo-class?</a>
    
    A CSS pseudo-class is a keyword added to a selector that specifies a special state of the selected element(s).
    
18. <a id="css-pseudo-elements">Explain the concept of pseudo-elements in CSS.</a>

    It is a feature of CSS which is used to style the given parts of an element.
    
    For Example, we can style the first letter or line of an HTML element.
    
        selector::pseudo-element {
            property:value;
        }
        
        p::first-line { ... }
        span::first-letter { ... }
        ::selection { ... }
        .header::after { ... }
        .tooltip::before { ... }
        
19. <a id="css-opacity">What is CSS opacity?</a>

    It is the property that elaborates on the transparency of an element.
    
    By this property, we can transparent the image that can take the values from 0.0-1.0. If the value is lower, then the image is more transparent. IE8 and earlier versions of the browser can take the values from 0-100.
    
20. <a id="css-position-states">Write all the position states used in CSS.</a>

    In CSS, there are four position states as stated below:
    
    * Static
    * Relative
    * Fixed
    * Absolute
    
21. <a id="css-rel-abs-diff">What are the differences between relative and absolute in CSS?</a>

    The main difference between relative and absolute is that “relative” is used for the same tag in CSS and it means that if we write the left:10px then the padding will shift to 10px in the left while absolute is totally relative to the non-static parent. It means, if we write left:10px then the result will be 10px far from the left edge of the parent element.
    
22. <a id="css-important">Define ‘important’ declarations used in CSS.</a>

    Important declarations are defined as that declaration which is having more importance than the normal declaration.
    
    While executing, these declarations override the declaration which is having less importance.

23. <a id="css-cascading">Define different cascading methods that can be used inside the cascading order.</a>

    Cascading order is itself a sorting method that allows many other different sorting methods:
    
    a) Sort by origin: There are some rules which can provide an alternate way defined as:
    
        - The normal weight of the style sheet of a particular provider will be overridden by the increased weight of the user's style sheet.
        - Stylesheet rules of a particular user will be overridden by the normal width of the provider’s style sheet.
        
    b) Sort by selector's specificity: Less specific selector is been overridden by the more specific selector.
    
    c) Sort by order specified: This comes in the scenario when the two selectors are of same weight and the other properties than the specification which will be seen for overriding.
    
24. <a id="css-inline-block">Differentiate between inline and block element.</a>

    Inline element does not have an element to set width and height and also it does not have the line break.
    
    Block element specification:
    
    - They do have the line break.
    - They define the width by setting a container and also allow setting height.
    - It can also contain an element that occurs in the inline element.
    
25. <a id="css-inherit">How is the concept of inheritance applied in CSS?</a>

    Inheritance is a concept in which the child class will inherit the properties of its parent class. It is a concept which is been used in many languages and is the easy way of defining the same property again.
    
    It is used in CSS to define the hierarchy from the top level to the bottom level. Inherited properties can be overridden by the children's class if the child uses the same name.
    
26. <a id="css-universal-selector">Explain universal selector.</a>

    The universal selector matches the name of any of the element type instead of selecting elements of a specific type.
    
27. <a id="css-background-color">Name the property used to specify the background color of an element.</a>

    The background-color property is used to specify the background color of the element. For example:
    
        <style>    
        h2,p{    
            background-color: #b0d4de;    
        }    
        </style>
        
28. <a id="css-repeat">Name the property for controlling the image repetition of the background.</a>

    The background-repeat property repeats the background image horizontally and vertically. Some images are repeated only horizontally or vertically.
    
29. <a id="css-image-position">Name the property for controlling the image position in the background.</a>

    The background-position property is used to define the initial position of the background image. By default, the background image is placed on the top-left of the webpage.
    
    You can set the following positions:
    
    * center
    * top
    * bottom
    * left
    * right
    
30. <a id="css-background-attachment">Name the property for controlling the image scroll in the background.</a>

    The background-attachment property is used to specify if the background image is fixed or scroll with the rest of the page in the browser window. If you set fixed the background image, then the image not move during scrolling in the browser. Let's take an example with the fixed background image.
    
        background: white url('bbb.gif');  
        background-repeat: no-repeat;  
        background-attachment: fixed;  
        
31. <a id="css-sprites">What are the benefits of CSS sprites?</a>

    If a web page has a large number of images that take a longer time to load because each image separately sends out an HTTP request. The concept of CSS sprites is used to reduce the loading time for a web page because it combines the various small images into one image. It reduces the number of HTTP requests and hence the loading time.
    
32. <a id="css-attr">What are attributes and how are they used?</a>

    You can target elements with particular attributes by using square brackets: ```[attribute="value"]```. For example, you can target all input fields that are of type radio like so:
    
        input[type="radio"] {
            background-color: #eee;
        }
        
33. <a id="css-fonts">What’s your preferred way of sizing fonts?</a>

     You can of course use pixels (px), but there’s also em, rem, %, vs and vh, along with a few others.
     
     Defining your font sizes in em allows you to change the size of your text based on the size defined at a higher level. For example, if a container has specified a font-size of 2em, and you specify a font-size of 2em on an element inside that container, that element has an effective font-size of 4em! However, this can be a little confusing as you might not always see the size you expect!
     
     The rem unit was created to remedy that confusion. It scales well in the browser, just like em and px, but it uses a base size. From that, all further rem values are calculated. For example, if your base rem value is equal to 16px, then 1rem will always be equal to 16px, 2rem will always be equal to 32px, and so on.
     
34. <a id="css-font-safe">What are web safe fonts and fallback fonts?</a>

    Not all operating systems and browsers have the same fonts installed. Web safe fonts are fonts that are commonly pre-installed on many computer systems, such as Arial and Times New Roman. In case the browser or operating system doesn’t recognize the first font you set (e.g. Ubuntu), you should choose a web safe fallback font to display (e.g. Arial), followed by a generic font family (e.g. sans-serif). If your fallback font doesn’t display either, the browser can pick a generic font in the sans-serif family.
    
35. <a id="css-how-use-media">How would you use media queries in a mobile-first approach?</a>

    There’s no way to avoid these nowadays, everyone expects their website to work on mobile devices, even if they don’t specifically ask for it.
    
    The most common approach is the mobile-first one. All styles outside of media queries are targeted at mobile devices. Then, through progressively larger media queries, you can style larger screens one step at a time.
    
        body { 
            font-size: 1em;
        }
        
        /* desktop styles */
        @media only screen and (min-width: 768px) {
            body {
                font-size: 1.5em;
            }
        }
        
36. <a id="css-flex-grid">Have you used Flexbox & CSS Grid before? What are the differences between them?</a>

    Flexbox is a very useful layout tool, especially for smaller areas within the site. Its main features are to align items in horizontal or vertical axes, space them out automatically, invert the order in which they’re displayed, along with a few other layout options.
    
    CSS Grid is more of a layout tool for the entire page. While Flexbox excels in laying out items along a single axis, Grid is better for layouts with both horizontal and vertical axes, i.e. grids!
    
### Javascript

1. <a id="js-what-is">What is JavaScript?</a>

    JavaScript is the most popular web scripting language, used for both client-side as well as server-side development. Supporting object-oriented programming abilities, the JavaScript code can be inserted into HTML pages that can be understood and executed by web browsers.
    
2. <a id="types">What are JavaScript Data Types?</a>

    * Boolean
    * null
    * number
    * object
    * string
    * symbol
    * undefined
    * bigInt
    
3. <a id="#js-isNaN">What is the use of isNaN function?</a>

    isNan function returns true if the argument is not a number otherwise it is false.
    
4. <a id="js-infinity">What is negative infinity?</a>

    Negative Infinity is a number in JavaScript which can be derived by dividing negative number by zero.
    
5. <a id="js-global-variables">What are global variables? How are these variable declared and what are the problems associated with using them?</a>

    Global variables are those that are available throughout the length of the code, that is, these have no scope. The var keyword is used to declare a local variable or object. If the var keyword is omitted, a global variable is declared.
    
    Example:
    
        Declare a global globalVariable = "Test";
    
    The problems that are faced by using global variables are the clash of variable names of local and global scope. Also, it is difficult to debug and test the code that relies on global variables.

6. <a id="js-difference-undefined-null">What's the difference between undefined and null?</a>

    * ```undefined``` is the default value of a variable that has not been assigned a specific value. Or a function that has no explicit return value ex. Or a property that does not exist in an object. The JavaScript engine does this for us the assigning of undefined value.
    * ```null``` is "a value that represents no value". null is value that has been explicitly defined to a variable. In this example we get a value of null when the fs.readFile method does not throw an error.
    
    When comparing ```null``` and ```undefined``` we get true when using ```==``` and false when using ```===.```.
    
7. <a id="js-&&">What does the && operator do?</a>

    The ```&&``` or Logical AND operator finds the first falsy expression in its operands and returns it and if it does not find any falsy expression it returns the last expression.
    
8. <a id="js-||">What does the || operator do?</a>

    The ```||``` or Logical OR operator finds the first truthy expression in its operands and returns it.
    
9. <a id="js-+">Is using the + or unary plus operator the fastest way in converting a string to a number?</a>

    According to MDN Documentation the ```+``` is the fastest way of converting a string to a number because it does not perform any operations on the value if it is already a number.

10. <a id="js-what-is-dom">What is the DOM?</a>
    
    DOM stands for Document Object Model is an interface (API) for HTML and XML documents. When the browser first reads (parses) our HTML document it creates a big object, a really big object based on the HTML document this is the DOM. It is a tree-like structure that is modeled from the HTML document. The DOM is used for interacting and modifying the DOM structure or specific Elements or Nodes.
    
    Imagine if we have an HTML structure like this.
    
        <!DOCTYPE html>
           <html lang="en">
           
           <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <meta http-equiv="X-UA-Compatible" content="ie=edge">
              <title>Document Object Model</title>
           </head>
           
           <body>
              <div>
                 <p>
                    <span></span>
                 </p>
                 <label></label>
                 <input>
              </div>
           </body>
           
           </html>
    
    The DOM equivalent would be like this.
    
    ![dom-tree](./images/dom-tree.png "dom-tree")
    
    The document object in JavaScript represents the DOM. It provides us many methods that we can use to selecting elements to update element contents and many more.
11. <a id="js-event-propagation">What is Event Propagation?</a>

    When an event occurs on a DOM element, that event does not entirely occur on that just one element. In the Bubbling Phase, the event bubbles up or it goes to its parent, to its grandparents, to its grandparent's parent until it reaches all the way to the window while in the Capturing Phase the event starts from the window down to the element that triggered the event or the event.target.
    
    Event Propagation has three phases.
    
    * ```Capturing Phase``` – the event starts from window then goes down to every element until it reaches the target element.
    * ```Target Phase``` – the event has reached the target element.
    * ```Bubbling Phase``` – the event bubbles up from the target element then goes up every element until it reaches the window.
    
    ![event-propagation](./images/event-propagation.png "event-propagation")
    
12. <a id="js-event-bubbling">What's Event Bubbling?</a>

    When an event occurs on a DOM element, that event does not entirely occur on that just one element. In the Bubbling Phase, the event bubbles up or it goes to its parent, to its grandparents, to its grandparent's parent until it reaches all the way to the window.
    
    The addEventListener method has a third optional parameter useCapture with a default value of false the event will occur in the Bubbling phase if true the event will occur in the Capturing Phase. If we click on the child element it logs child,parent,grandparent, html, document and window respectively on the console. This is Event Bubbling.
     
13. <a id="js-event-capturing">What's Event Capturing?</a>

    When an event occurs on a DOM element, that event does not entirely occur on that just one element. In Capturing Phase, the event starts from the window all the way down to the element that triggered the event.
    
    The addEventListener method has a third optional parameter useCapture with a default value of false the event will occur in the Bubbling phase if true the event will occur in the Capturing Phase. If we click on the child element it logs window,document,html, grandparent and parent and child respectively on the console. This is Event Capturing.

14. <a id="js-diff-prevent-propagation">What's the difference between event.preventDefault() and event.stopPropagation() methods?</a>

    The event.preventDefault() method prevents the default behavior of an element. If used in a form element it prevents it from submitting. If used in an anchor element it prevents it from navigating. If used in a contextmenu it prevents it from showing or displaying. While the event.stopPropagation() method stops the propogation of an event or it stops the event from occurring in the bubbling or capturing phase.

15. <a id="js-preventDef-known-use">How to know if the event.preventDefault() method was used in an element?</a>

    We can use the event.defaultPrevented property in the event object. It returns a boolean indicating if the event.preventDefault() was called in a particular element.

16. <a id="js-error-obj-property">Why does this code obj.someprop.x throw an error?</a>

        const obj = {};
        console.log(obj.someprop.x);
        
    Obviously, this throws an error due to the reason we are trying to access a ```x``` property in the ```someprop``` property which have an ```undefined``` value. Remember properties in an object which does not exist in itself and its prototype has a default value of ```undefined``` and ```undefined``` has no property ```x```.

17. <a id="js-event-target">What is event.target ?</a>

    In simplest terms, the event.target is the element on which the event occurred or the element that triggered the event.

18. <a id="js-current-target">What is event.currentTarget?</a>

    The event.currentTarget is the element on which we attach the event handler explicitly.
    
    Sample HTML Markup.
    
        <div onclick="clickFunc(event)" style="text-align: center;margin:15px;
        border:1px solid red;border-radius:3px;">
            <div style="margin: 25px; border:1px solid royalblue;border-radius:3px;">
                <div style="margin:25px;border:1px solid skyblue;border-radius:3px;">
                  <button style="margin:10px">
                     Button
                  </button>
                </div>
            </div>
          </div>
     
     Sample JavaScript.
     
         function clickFunc(event) {
          console.log(event.target);
        }
        
    If you click the button it will log the button markup even though we attach the event on the outermost div it will always log the button so we can conclude that the event.target is the element that triggered the event.
    
19. <a id="js-diff-comparing">What's the difference between == and ===?</a>

    The difference between ```==```(abstract equality) and ```===```(strict equality) is that the ```==``` compares by value after coercion and ```===``` compares by value and type without coercion.
    
    Let's dig deeper on the ```==.``` So first let's talk about coercion.
    
    Coercion is the process of converting a value to another type. As in this case, the ```==``` does implicit coercion. The ```==``` has some conditions to perform before comparing the two values.
    
    Suppose we have to compare ```x == y``` values.
    
    * If ```x``` and ```y``` have same type. Then compare them with the ```===``` operator.
    * If ```x``` is ```null``` and ```y``` is ```undefined``` then return true.
    * If ```x``` is ```undefined``` and ```y``` is ```null``` then return true.
    * If ```x``` is type ```number``` and ```y``` is type ```string``` Then return ```x == toNumber(y)```.
    * If ```x``` is type ```string``` and ```y``` is type ```number``` Then return ```toNumber(x) == y```.
    * If ```x``` is type ```boolean``` Then return ```toNumber(x) == y```.
    * If ```y``` is type ```boolean``` Then return ```x == toNumber(y)```.
    * If ```x``` is either ```string,symbol or number``` and ```y``` is type ```object``` Then return ```x == toPrimitive(y)```.
    * If ```x``` is either ```object``` and ```x``` is either ```string,symbol``` Then return ```toPrimitive(x) == y```.
    
    ```toPrimitive``` uses first the valueOf method then the toString method in objects to get the primitive value of that object.
    
20. <a id="js-comparing-two-obj">Why does it return false when comparing two similar objects in JavaScript?</a>

    JavaScript compares objects and primitives differently. In primitives it compares them by value while in objects it compares them by reference or the address in memory where the variable is stored.

21. <a id="js-oper!!-do">What does the !! operator do?</a>

    The Double NOT operator or !! coerces the value on the right side into a boolean. basically it's a fancy way of converting a value into a boolean.

22. <a id="js-one-line">How to evaluate multiple expressions in one line?</a>

    We can use the , or comma operator to evaluate multiple expressions in one line. It evaluates from left-to-right and returns the value of the last item on the right or the last operand.
    
        let x = 5;
        
        x = (x++ , x = addFive(x), x *= 2, x -= 5, x += 10);
        
        function addFive(num) {
          return num + 5;
        }
        
    If you log the value of x it would be 27. First, we increment the value of x it would be 6, then we invoke the function addFive(6) and pass the 6 as a parameter and assign the result to x the new value of x would be 11. After that, we multiply the current value of x to 2 and assign it to x the updated value of x would be 22. Then, we subtract the current value of x to 5 and assign the result to x the updated value would be 17. And lastly, we increment the value of x by 10 and assign the updated value to x now the value of x would be 27.

23. <a id="js-hoisting">What is Hoisting?</a>

    Hoisting is the term used to describe the moving of variables and functions to the top of their (global or function) scope on where we define that variable or function.
    
    Ok to understand Hoisting, I have to explain the execution context.
    The Execution Context is the "environment of code" that is currently executing. The Execution Context has two phases compilation and execution.
    
    ```Compilation``` - in this phase it gets all the function declarations and hoists them up to the top of their scope so we can reference them later and gets all variables declaration (declare with the var keyword) and also hoists them up and give them a default value of undefined.
    
    ```Execution``` - in this phase it assigns values to the variables hoisted earlier and it executes or invokes functions (methods in objects).
    
    ```Note```: only function declarations and variables declared with the var keyword are hoisted not function expressions or arrow functions, let and const keywords.
    
    Ok, suppose we have an example code in the global scope below.
    
        console.log(y);
        y = 1;
        console.log(y);
        console.log(greet("Mark"));
        
        function greet(name){
          return 'Hello ' + name + '!';
        }
        
        var y;
        
    This code logs undefined,1, Hello Mark! respectively.
    
    So the compilation phase would look like this.
    
        function greet(name) {
          return 'Hello ' + name + '!';
        }
        
        var y; //implicit "undefined" assignment
        
        //waiting for "compilation" phase to finish
        
        //then start "execution" phase
        /*
        console.log(y);
        y = 1;
        console.log(y);
        console.log(greet("Mark"));
        */

    for example purposes, I commented on the assignment of variable and function call.
    
    After the compilation phase finishes it starts the execution phase invoking methods and assigns values to variables.
    
        function greet(name) {
          return 'Hello ' + name + '!';
        }
        
        var y;
        
        //start "execution" phase
        
        console.log(y);
        y = 1;
        console.log(y);
        console.log(greet("Mark"));
        
24. <a id="js-scope">What is Scope?</a>

    Scope in JavaScript is the area where we have valid access to variables or functions. JavaScript has three types of Scopes. ```Global Scope, Function Scope,``` and ```Block Scope(ES6)```.
    
    * ```Global Scope``` - variables or functions declared in the global namespace are in the global scope and therefore is accessible everywhere in our code.
    
           //global namespace
           var g = "global";
        
           function globalFunc(){
             function innerFunc(){
                  console.log(g); // can access "g" because "g" is a global variable
             }
             innerFunc();
           }  
    
    * ```Function Scope``` - variables,functions and parameters declared within a function are accessible inside that function but not outside of it.
    
            function myFavoriteFunc(a) {
               if (true) {
                  var b = "Hello " + a;
               }
               return b;
           }
           myFavoriteFunc("World");
        
           console.log(a); // Throws a ReferenceError "a" is not defined
           console.log(b); // does not continue here 
           
    * ```Block Scope``` - variables (let,const) declared within a block {} can only be access within it.
    
             function testBlock(){
               if(true){
                 let z = 5;
               }
               return z; 
             }
            
             testBlock(); // Throws a ReferenceError "z" is not defined
             
    Scope is also a set of rules for finding variables. If a variable does not exist in the current scope it look ups and searches for a variable in the outer scope and if does not exist again it looks up again until it reaches the global scope if the variable exists then we can use it if not it throws an error. It searches for the nearest variable and it stops searching or looking up once it finds it. This is called Scope Chain.
    
           /* Scope Chain
           Inside inner function perspective
        
           inner's scope -> outer's scope -> global's scope
          */
        
        
          //Global Scope
          var variable1 = "Comrades";   
          var variable2 = "Sayonara";
        
          function outer(){
          //outer's scope
            var variable1 = "World";
            function inner(){
            //inner's scope
              var variable2 = "Hello";
              console.log(variable2 + " " + variable1);
            }
            inner();
          }  
          outer(); 
        // logs Hello World 
        // because (variable2 = "Hello") and (variable1 = "World") are the nearest 
        // variables inside inner's scope.
    
25. <a id="js-closures">What are Closures?</a>

    Closures is simply the ability of a function at the time of declaration to remember the references of variables and parameters on its current scope, on its parent function scope, on its parent's parent function scope until it reaches the global scope with the help of Scope Chain. Basically it is the Scope created when the function was declared.
    
    Examples are a great way to explain closures.
    
           //Global's Scope
           var globalVar = "abc";
        
           function a(){
           //testClosures's Scope
             console.log(globalVar);
           }
        
           a(); //logs "abc" 
           /* Scope Chain
              Inside a function perspective
        
              a's scope -> global's scope  
           */ 
           
    In this example, when we declare the a function the Global Scope is part of a's closure.
    
    ![closures](./images/closures-1.png "closures")
    
    The reason for the variable ```globalVar``` which does not have a value in the image because of the reason that the value of that variable can change based on where and when we invoke the ```a``` function.
    But in our example above the ```globalVar``` variable will have the value of abc.
    
    Ok, let's have a complex example.
    
            var globalVar = "global";
            var outerVar = "outer"
            
            function outerFunc(outerParam) {
              function innerFunc(innerParam) {
                console.log(globalVar, outerParam, innerParam);
              }
              return innerFunc;
            }
            
            const x = outerFunc(outerVar);
            outerVar = "outer-2";
            globalVar = "guess"
            x("inner");
            
    ![closures](./images/closures-2.png "closures")
    
    This will print "guess outer inner". The explanation for this is that when we invoke the outerFunc function and assigned the returned value the innerFunc function to the variable x, the outerParam will have a value of outer even though we assign a new value outer-2 to the outerVar variable because
    the reassignment happened after the invocation of the outer function and in that time when we invoke the outerFunc function it's look up the value of outerVar in the Scope Chain, the outerVar will have a value of "outer". Now, when we invoke the x variable which have a reference to the innerFunc, the
    innerParam will have a value of inner because thats the value we pass in the invocation and the globalVar variable will have a value of guess because before the invocation of the x variable we assign a new value to the globalVar and at the time of invocation x the value of globalVar in the_Scope Chain_ is
    guess.
    
    We have an example that demonstrates a problem of not understanding closure correctly.
    
        const arrFuncs = [];
        for(var i = 0; i < 5; i++){
          arrFuncs.push(function (){
            return i;
          });
        }
        console.log(i); // i is 5
        
        for (let i = 0; i < arrFuncs.length; i++) {
          console.log(arrFuncs[i]()); // all logs "5"
        }
        
    This code is not working as we expected because of Closures.
    The var keyword makes a global variable and when we push a function
    we return the global variable i. So when we call one of those functions in that array after the loop it logs 5 because we get
    the current value of i which is 5 and we can access it because it's a global variable. Because Closures keeps the references of that variable not its values at the time of it's creation. We can solve this using IIFES or changing the var keyword to let for block-scoping.
    
26. <a id="js-falsy-values">What are the falsy values in JavaScript?</a>

    const falsyValues = ['', 0, null, undefined, NaN, false];
    
    falsy values are values that when converted to boolean becomes false.

27. <a id="js-check-falsy">How to check if a value is falsy?</a>

    Use the Boolean function or the Double NOT operator !!

28. <a id="js-use-strict">What does "use strict" do?</a>

    ```use strict``` is a ES5 feature in JavaScript that makes our code in Strict Mode in functions or entire scripts. Strict Mode helps us avoid bugs early on in our code and adds restrictions to it.
    
    Restrictions that Strict Mode gives us.
    
    * Assigning or Accessing a variable that is not declared.
    
             function returnY(){
                "use strict";
                y = 123;
                return y;
             }
             
    * Assigning a value to a read-only or non-writable global variable;
    
               "use strict";
               var NaN = NaN;
               var undefined = undefined;
               var Infinity = "and beyond";
               
    * Deleting an undeletable property.
    
               "use strict";
               const obj = {};
            
               Object.defineProperty(obj, 'x', {
                  value : '1'
               });  
            
               delete obj.x;
                   
    * Duplicate parameter names.
    
             "use strict";
            
               function someFunc(a, b, b, c){
            
               }
               
    * Creating variables with the use of the eval function.
    
             "use strict";
            
             eval("var x = 1;");
            
             console.log(x); //Throws a Reference Error x is not defined
             
    * The default value of this will be undefined.
    
            "use strict";
            
            function showMeThis(){
                return this;
            }
            
            showMeThis(); //returns undefined

    There are many more restrictions in Strict Mode than these.

29. <a id="js-this">What's the value of this in JavaScript?</a>

    Basically, this refers to the value of the object that is currently executing or invoking the function. I say currently due to the reason that the value of this changes depending on the context on which we use it and where we use it.
    
           const carDetails = {
             name: "Ford Mustang",
             yearBought: 2005,
             getName(){
                return this.name;
             },
             isRegistered: true
           };
        
           console.log(carDetails.getName()); // logs Ford Mustang
           
    This is what we would normally expect because in the getName method we return this.name, this in this context refers to the object which is the carDetails object that is currently the "owner" object of the function executing.
    
    Ok, Let's some add some code to make it weird. Below the console.log statement add this three lines of code
    
           var name = "Ford Ranger";
           var getCarName = carDetails.getName;
        
           console.log(getCarName()); // logs Ford Ranger
           
    The second console.log statement prints the word Ford Ranger which is weird because in our first console.log statement it printed Ford Mustang. The reason to this is that the getCarName method has a different "owner" object that is the window object. Declaring variables with the var keyword in the global scope attaches properties in the window object with the same name as the variables. Remember this in the global scope refers to the window object when "use strict" is not used.
    
          console.log(getCarName === window.getCarName); //logs true
          console.log(getCarName === this.getCarName); // logs true
          
    ```this``` and ```window``` in this example refer to the same object.
    
    One way of solving this problem is by using the apply and call methods in functions.
    
           console.log(getCarName.apply(carDetails)); //logs Ford Mustang
           console.log(getCarName.call(carDetails));  //logs Ford Mustang
           
    The ```apply``` and ```call``` methods expects the first parameter to be an object which would be value of this inside that function.
    
    ```IIFE``` or ```Immediately Invoked Function Expression```, ```Functions that are declared in the global scope, Anonymous Functions and Inner functions in methods inside an object``` has a default of this which points to the window object.
    
           (function (){
             console.log(this);
           })(); //logs the "window" object
        
           function iHateThis(){
              console.log(this);
           }
        
           iHateThis(); //logs the "window" object  
        
           const myFavoriteObj = {
             guessThis(){
                function getThis(){
                  console.log(this);
                }
                getThis();
             },
             name: 'Marko Polo',
             thisIsAnnoying(callback){
               callback();
             }
           };
        
        
           myFavoriteObj.guessThis(); //logs the "window" object
           myFavoriteObj.thisIsAnnoying(function (){
             console.log(this); //logs the "window" object
           });
           
    If we want to get the value of the name property which is Marko Polo in the myFavoriteObj object there are two ways to solve this.
    
    First, we save the value of this in a variable.
    
           const myFavoriteObj = {
             guessThis(){
                 const self = this; //saves the this value to the "self" variable
                 function getName(){
                   console.log(self.name);
                 }
                 getName();
             },
             name: 'Marko Polo',
             thisIsAnnoying(callback){
               callback();
             }
           };
           
    In this image we save the value of this which would be the myFavoriteObj object. So we can access it inside the getName inner function.
    
    Second, we use ES6 Arrow Functions.
    
           const myFavoriteObj = {
             guessThis(){
                 const getName = () => { 
                   //copies the value of "this" outside of this arrow function
                   console.log(this.name);
                 }
                 getName();
             },
             name: 'Marko Polo',
             thisIsAnnoying(callback){
               callback();
             }
           };
           
    Arrow Functions does not have its own this. It copies the value of this of the enclosing lexical scope or in this example the value of this outside the getName inner function which would be the myFavoriteObj object. We can also determine the value of this on how the function is invoked.
    
30. <a id="js-prototype">What is the prototype of an object?</a>

    A prototype in simplest terms is a blueprint of an object. It is used as a fallback for properties and methods if it does exist in the current object. It's the way to share properties and functionality between objects. It's the core concept around JavaScript's Prototypal Inheritance.
    
          const o = {};
          console.log(o.toString()); // logs [object Object] 
          
    Even though the o.toString method does not exist in the o object it does not throw an error instead returns a string [object Object]. When a property does not exist in the object it looks into its prototype and if it still does not exist it looks into the prototype's prototype and so on until it finds a property with the same in the Prototype Chain. The end of the Prototype Chain is the Object.prototype.
    
        console.log(o.toString === Object.prototype.toString); // logs true
        // which means we we're looking up the Prototype Chain and it reached 
        // the Object.prototype and used the "toString" method.
    
31. <a id="js-iive">What is an IIFE, what is the use of it?</a>

    An ```IIFE``` or ```Immediately Invoked Function Expression``` is a function that is gonna get invoked or executed after its creation or declaration. The syntax for creating IIFE is that we wrap the ```function (){}``` inside a parentheses ```()``` or the Grouping Operator to treat the function as an expression and after that we invoke it with another parentheses ```()```. So an IIFE looks like this ```(function(){})()```.
    
        (function () {
        
        }());
        
        (function () {
        
        })();
        
        (function named(params) {
        
        })();
        
        (() => {
        
        })();
        
        (function (global) {
        
        })(window);
        
        const utility = (function () {
           return {
              //utilities
           };
        })();
        
    These examples are all valid IIFE. The second to the last example shows we can pass arguments to an IIFE function. The last example shows that we can save the result of the IIFE to a variable so we can reference it later.
    
    The best use of IIFE is making initialization setup functionalities and to avoid naming collisions with other variables in the global scope or polluting the global namespace. Let's have an example.
    
        <script src="https://cdnurl.com/somelibrary.js"></script>
        
    Suppose we have a link to a library somelibrary.js that exposes some global functions that we use can in our code but this library has two methods that we don't use createGraph and drawGraph because these methods have bugs in them. And we want to implement our own createGraph and drawGraph methods.
    
    * One way of solving this is by changing the structure of our scripts.
    
        <script src="https://cdnurl.com/somelibrary.js"></script>
        <script>
           function createGraph() {
              // createGraph logic here
           }
           function drawGraph() {
              // drawGraph logic here
           }
        </script>
        
    When we use this solution we are overriding those two methods that the library gives us.
    
    * Another way of solving this is by changing the name of our own helper functions.
    
        <script src="https://cdnurl.com/somelibrary.js"></script>
        <script>
           function myCreateGraph() {
              // createGraph logic here
           }
           function myDrawGraph() {
              // drawGraph logic here
           }
        </script>
        
    When we use this solution we will also change those function calls to the new function names.
    
    * Another way is using an IIFE.
    
            <script src="https://cdnurl.com/somelibrary.js"></script>
            <script>
               const graphUtility = (function () {
                  function createGraph() {
                     // createGraph logic here
                  }
                  function drawGraph() {
                     // drawGraph logic here
                  }
                  return {
                     createGraph,
                     drawGraph
                  }
               })();
            </script>
        
    In this solution, we are making a utility variable that is the result of IIFE which returns an object that contains two methods ```createGraph``` and ```drawGraph```.
    
    Another problem that IIFE solves is in this example.
    
        var li = document.querySelectorAll('.list-group > li');
        for (var i = 0, len = li.length; i < len; i++) {
           li[i].addEventListener('click', function (e) {
              console.log(i);
           })
        }
        
    Suppose we have a ul element with a class of list-group and it has 5 li child elements. And we want to console.log the value of i when we click an individual li element.
    But the behavior we want in this code does not work. Instead, it logs 5 in any click on an li element. The problem we're having is due to how Closures work. Closures are simply the ability of functions to remember the references of variables on its current scope, on its parent function scope and in the global scope. When we declare variables using the var keyword in the global scope, obviously we are making a global variable i. So when we click an li element it logs 5 because that is the value of i when we reference it later in the callback function.
    
    * One solution to this is an IIFE.
    
            var li = document.querySelectorAll('.list-group > li');
            for (var i = 0, len = li.length; i < len; i++) {
               (function (currentIndex) {
                  li[currentIndex].addEventListener('click', function (e) {
                     console.log(currentIndex);
                  })
               })(i);
            }
            
    This solution works because of the reason that the IIFE creates a new scope for every iteration and we capture the value of i and pass it into the currentIndex parameter so the value of currentIndex is different for every iteration when we invoke the IIFE.
    
32. <a id="js-apply">What is the use ```Function.prototype.apply``` method?</a>

    The apply invokes a function specifying the this or the "owner" object of that function on that time of invocation.
    
        const details = {
          message: 'Hello World!'
        };
        
        function getMessage(){
          return this.message;
        }
        
        getMessage.apply(details); // returns 'Hello World!'
        
    This method works like Function.prototype.call the only difference is how we pass arguments. In apply we pass arguments as an array.
    
        const person = {
          name: "Marko Polo"
        };
        
        function greeting(greetingMessage) {
          return `${greetingMessage} ${this.name}`;
        }
        
        greeting.apply(person, ['Hello']); // returns "Hello Marko Polo!"
        
33. <a id="js-call">What is the use Function.prototype.call method?</a>

    The call invokes a function specifying the this or the "owner" object of that function on that time of invocation.
    
        const details = {
          message: 'Hello World!'
        };
        
        function getMessage(){
          return this.message;
        }
        
        getMessage.call(details); // returns 'Hello World!'
        
    This method works like Function.prototype.apply the only difference is how we pass arguments. In call we pass directly the arguments separating them with a comma , for every argument.
    
        const person = {
          name: "Marko Polo"
        };
        
        function greeting(greetingMessage) {
          return `${greetingMessage} ${this.name}`;
        }
        
        greeting.call(person, 'Hello'); // returns "Hello Marko Polo!"
        
34. <a id="js-diff-apply-call">What's the difference between Function.prototype.apply and Function.prototype.call?</a>

    The only difference between apply and call is how we pass the arguments in the function being called. In apply we pass the arguments as an array and in call we pass the arguments directly in the argument list.
    
        const obj1 = {
         result:0
        };
        
        const obj2 = {
         result:0
        };
        
        function reduceAdd(){
           let result = 0;
           for(let i = 0, len = arguments.length; i < len; i++){
             result += arguments[i];
           }
           this.result = result;
        }
        
        reduceAdd.apply(obj1, [1, 2, 3, 4, 5]); // returns 15
        reduceAdd.call(obj2, 1, 2, 3, 4, 5); // returns 15

35. <a id="">What is the usage of ```Function.prototype.bind```?</a>

    The bind method returns a new function that is bound
    to a specific this value or the "owner" object, So we can use it later in our code. The call,apply methods invokes the function immediately instead of returning a new function like the bind method.
    
        import React from 'react';
        
        class MyComponent extends React.Component {
             constructor(props){
                  super(props); 
                  this.state = {
                     value : ""
                  }  
                  this.handleChange = this.handleChange.bind(this); 
                  // Binds the "handleChange" method to the "MyComponent" component
             }
        
             handleChange(e){
               //do something amazing here
             }
        
             render(){
                return (
                      <>
                        <input type={this.props.type}
                                value={this.state.value}
                             onChange={this.handleChange}                      
                          />
                      </>
                )
             }
        }
    
36. <a id="js-functional-programing">What is Functional Programming and what are the features of JavaScript that makes it a candidate as a functional language?</a>

    Functional Programming is a declarative programming paradigm or pattern on how we build our applications with functions using expressions that calculates a value without mutating or changing the arguments that are passed to it.
    
    JavaScript Array has map, filter, reduce methods which are the most famous functions in the functional programming world because of their usefulness and because they don't mutate or change the array which makes these functions pure and JavaScript supports Closures and Higher Order Functions which are a characteristic of a Functional Programming Language.
    
37. <a id="js-high-order-functions">What are Higher Order Functions?</a>

    Higher-Order Function are functions that can return a function or receive argument or arguments which have a value of a function.
    
        function higherOrderFunction(param,callback){
            return callback(param);
        }

38. <a id="js-why-func-call-obj">Why are functions called First-class Objects?</a>

    Functions in JavaScript are First-class Objects because they are treated as any other value in the language. They can be assigned to variables, they can be properties of an object which are called methods, they can be an item in array, they can be passed as arguments to a function, and they can be returned as values of a function. The only difference between a function and any other value in JavaScript is that functions can be invoked or called.

39. <a id="js-impl-map">Implement the Array.prototype.map method by hand.</a>

        Array.prototype.map = function(callback){
        	const newArray = [];
          
        	for (let i = 0; i < this.length; i += 1) {
          	newArray.push(callback(this[i], i, this));
          }
          
          return newArray;
        }

40. <a id="js-impl-filter">Implement the Array.prototype.filter method by hand.</a>

        Array.prototype.filter = function(callback) {
        	const filteredArray = [];
          
          for	(let i = 0; i < this.length; i += 1) {
          
            let isTrue = !!callback(this[i], i, this);
        
            if (isTrue) {
              filteredArray.push(this[i]);
            }
          
          }
          
          return filteredArray;
        }

41. <a id="js-impl-reduce">Implement the Array.prototype.reduce method by hand.</a>

        Array.prototype.reduce = function(callBack, startValue) {
        	let accum = startValue || this[0];
          
          for (let i = startValue ? 0 : 1; i < this.length; i += 1) {
          	accum = callBack(accum, this[i], i, this);
          }
          
          return accum;
          
        }

42. <a id="js-arg">What is the arguments object?</a>

    The arguments object is a collection of parameter values pass in a function. It's an Array-like object because it has a length property and we can access individual values using array indexing notation ```arguments[1]``` but it does not have the built-in methods in an array ```forEach```,```reduce```,```filter``` and ```map```.
    It helps us know the number of arguments pass in a function.
    
    We can convert the arguments object into an array using the ```Array.prototype.slice```.
    
        function one() {
          return Array.prototype.slice.call(arguments);
        }
        
    Note: the arguments object does not work on ES6 arrow functions.
    
        function one() {
          return arguments;
        }
        const two = function () {
          return arguments;
        }
        const three = function three() {
          return arguments;
        }
        
        const four = () => arguments;
        
        four(); // Throws an error  - arguments is not defined
        
    When we invoke the function ```four``` it throws a ```ReferenceError: arguments is not defined error```. We can solve this problem if your envinroment supports the ```rest``` syntax.
    
    This puts all parameter values in an array automatically.
    
43. <a id="js-create-obj-without-prot">How to create an object without a prototype?</a>

    We can create an object without a prototype using the Object.create method.
    
        const o1 = {};
           console.log(o1.toString()); 
           // logs [object Object] get this method to the Object.prototype 
        
           const o2 = Object.create(null);
           // the first parameter is the prototype of the object "o2" which in this
           // case will be null specifying we don't want any prototype
           console.log(o2.toString());
           // throws an error o2.toString is not a function 
    
44. <a id="js-44">Why does b in this code become a global variable when you call this function?</a>

        function myFunc() {
          let a = b = 0;
        }
        
        myFunc();
        
    The reason for this is that assignment operator or = has right-to-left associativity or evaluation. What this means is that when multiple assignment operators appear in a single expression they evaluated from right to left. So our code becomes likes this.
    
        function myFunc() {
          let a = (b = 0);
        }
        
        myFunc();
        
    First, the expression b = 0 evaluated and in this example b is not declared. So, The JS Engine makes a global variable b outside this function after that the return value of the expression b = 0 would be 0 and it's assigned to the new local variable a with a let keyword.
    
    We can solve this problem by declaring the variables first before assigning them with value.
    
        function myFunc() {
          let a,b;
          a = b = 0;
        }
        myFunc();

45. <a id="js-what-ECMA">What is ECMAScript?</a>

    ECMAScript is a standard for making scripting languages which means that JavaScript follows the specification changes in ECMAScript standard because it is the blueprint of JavaScript.

46. <a id="js-new-features-es6">What are the new features in ES6 or ECMAScript 2015?</a>

    * Arrow Functions
    * Classes
    * Template Strings
    * Enhanced Object literals
    * Object Destructuring
    * Promises
    * Generators
    * Modules
    * Symbol
    * Proxies
    * Sets
    * Default Function parameters
    * Rest and Spread
    * Block Scoping with let and const

47. <a id="js-var-let-const">What's the difference between var, let and const keywords?</a>

    Variables declared with var keyword are function scoped.
    What this means that variables can be accessed across that function even if we declare that variable inside a block.
    
        function giveMeX(showX) {
          if (showX) {
            var x = 5;
          }
          return x;
        }
        
        console.log(giveMeX(false));
        console.log(giveMeX(true));
        
    The first ```console.log``` statement logs ```undefined```
    and the second ```5```. We can access the ```x``` variable due
    to the reason that it gets hoisted at the top of the function scope. So our function code is intepreted like this.
    
        function giveMeX(showX) {
          var x; // has a default value of undefined
          if (showX) {
            x = 5;
          }
          return x;
        }
        
    If you are wondering why it logs ```undefined``` in the first ```console.log``` statement remember variables declared without an initial value has a default value of ```undefined```.
    
    Variables declared with ```let``` and ```const``` keyword are block scoped. What this means that variable can only be accessed on that block ```{}``` on where we declare it.
    
        function giveMeX(showX) {
          if (showX) {
            let x = 5;
          }
          return x;
        }
        
        
        function giveMeY(showY) {
          if (showY) {
            let y = 5;
          }
          return y;
        }
        
    If we call this functions with an argument of ```false``` it throws a ```Reference Error``` because we can't access the ```x``` and ```y``` variables outside that block and those variables are not hoisted.
    
    There is also a difference between ```let``` and ```const``` we can assign new values using ```let``` but we can't in ```const``` but const are mutable meaning. What this means is if the value that we assign to a ```const``` is an ```object``` we can change the values of those properties but can't reassign a new value to that variable.
    
49. <a id="js-classes">What are Arrow functions?</a>

    Arrow Functions are a new way of making functions in JavaScript. Arrow Functions takes a little time in making functions and has a cleaner syntax than a function expression because we omit the function keyword in making them.
        
        //ES5 Version
        var getCurrentDate = function (){
          return new Date();
        }
        
        //ES6 Version
        const getCurrentDate = () => new Date();
        
    In this example, in the ES5 Version have ```function(){}``` declaration and return keyword needed to make a function and ```return``` a value respectively. In the Arrow Function version we only need the ```()``` parentheses and we don't need a return statement because Arrow Functions have a implicit return if we have only one expression or value to return.
        
        //ES5 Version
        function greet(name) {
          return 'Hello ' + name + '!';
        }
        
        //ES6 Version
        const greet = (name) => `Hello ${name}`;
        const greet2 = name => `Hello ${name}`;
        
    We can also parameters in Arrow functions the same as the function expressions and function declarations. If we have one parameter in an Arrow Function we can omit the parentheses it is also valid.
        
        const getArgs = () => arguments
        
        const getArgs2 = (...rest) => rest
        
    Arrow functions don't have access to the arguments object. So calling the first getArgs func will throw an Error. Instead we can use the rest parameters to get all the arguments passed in an arrow function.
    
        const data = {
          result: 0,
          nums: [1, 2, 3, 4, 5],
          computeResult() {
            // "this" here refers to the "data" object
            const addAll = () => {
              // arrow functions "copies" the "this" value of 
              // the lexical enclosing function
              return this.nums.reduce((total, cur) => total + cur, 0)
            };
            this.result = addAll();
          }
        };
        
    Arrow functions don't have their own this value. It captures or gets the ```this``` value of lexically enclosing function or in this example, the ```addAll``` function copies the ```this``` value of the computeResult method and if we declare an arrow function in the global scope the value of ```this``` would be the ```window object```.
    
49. <a id="js-classes">What are Classes?</a>

    Classes is the new way of writing constructor functions in JavaScript. It is syntactic sugar for using constructor functions, it still uses prototypes and Prototype-Based Inheritance under the hood.
    
           //ES5 Version
           function Person(firstName, lastName, age, address){
              this.firstName = firstName;
              this.lastName = lastName;
              this.age = age;
              this.address = address;
           }
        
           Person.self = function(){
             return this;
           }
        
           Person.prototype.toString = function(){
             return "[object Person]";
           }
        
           Person.prototype.getFullName = function (){
             return this.firstName + " " + this.lastName;
           }  
        
           //ES6 Version
           class Person {
                constructor(firstName, lastName, age, address){
                    this.lastName = lastName;
                    this.firstName = firstName;
                    this.age = age;
                    this.address = address;
                }
        
                static self() {
                   return this;
                }
        
                toString(){
                   return "[object Person]";
                }
        
                getFullName(){
                   return `${this.firstName} ${this.lastName}`;
                }
           }
           
    Overriding Methods and Inheriting from another class.
       
        //ES5 Version
        Employee.prototype = Object.create(Person.prototype);
        
        function Employee(firstName, lastName, age, address, jobTitle, yearStarted) {
          Person.call(this, firstName, lastName, age, address);
          this.jobTitle = jobTitle;
          this.yearStarted = yearStarted;
        }
        
        Employee.prototype.describe = function () {
          return `I am ${this.getFullName()} and I have a position of ${this.jobTitle} and I started at ${this.yearStarted}`;
        }
        
        Employee.prototype.toString = function () {
          return "[object Employee]";
        }
        
        //ES6 Version
        class Employee extends Person { //Inherits from "Person" class
          constructor(firstName, lastName, age, address, jobTitle, yearStarted) {
            super(firstName, lastName, age, address);
            this.jobTitle = jobTitle;
            this.yearStarted = yearStarted;
          }
        
          describe() {
            return `I am ${this.getFullName()} and I have a position of ${this.jobTitle} and I started at ${this.yearStarted}`;
          }
        
          toString() { // Overriding the "toString" method of "Person"
            return "[object Employee]";
          }
        }
        
    So how do we know that it uses prototypes under the hood?
    
           class Something {
        
           }
        
           function AnotherSomething(){
        
           }
           const as = new AnotherSomething();
           const s = new Something();
        
           console.log(typeof Something); // logs "function"
           console.log(typeof AnotherSomething); // logs "function"
           console.log(as.toString()); // logs "[object Object]"
           console.log(as.toString()); // logs "[object Object]"
           console.log(as.toString === Object.prototype.toString); 
           console.log(s.toString === Object.prototype.toString); 
           // both logs return true indicating that we are still using 
           // prototypes under the hoods because the Object.prototype is
           // the last part of the Prototype Chain and "Something"
           // and "AnotherSomething" both inherit from Object.prototype
               
50. <a id="js-templ-literals">What are Template Literals?</a>

    Template Literals are a new way of making strings in JavaScript. We can make Template Literal by using the backtick or back-quote symbol.
    
        //ES5 Version
        var greet = 'Hi I\'m Mark';
        
        //ES6 Version
        let greet = `Hi I'm Mark`;
        
    In the ES5 version, we need to escape the ' using the \ to escape the normal functionality of that symbol which in this case is to finish that string value. In Template Literals, we don't need to do that.
    
        //ES5 Version
        var lastWords = '\n'
          + '   I  \n'
          + '   Am  \n'
          + 'Iron Man \n';
        
        
        //ES6 Version
        let lastWords = `
            I
            Am
          Iron Man   
        `;
        
    In the ES5 version, we need to add this \n to have a new line in our string. In Template Literals, we don't need to do that.
    
        //ES5 Version
        function greet(name) {
          return 'Hello ' + name + '!';
        }
        
        
        //ES6 Version
        function greet(name) {
          return `Hello ${name} !`;
        }
        
    In the ES5 version, If we need to add an expression or value in a string we need to use the + or string concatenation operator. In Template Literals, we can embed an expression using ${expr} which makes it cleaner than the ES5 version.

51. <a id="What are ES6 Modules?">js-es6-modules</a>

    Modules lets us split our code base to multiple files for more maintainability and this lets us avoid putting all of our code in one big file (yucksss). Before ES6 has supported Modules there were two popular module systems that were used for Code Maintainability in JavaScript.
    
    * CommonJS - Nodejs
    * AMD (Asynchronous Module Definition) - Browsers
    
    Basically, the sytanx for using modules are straightforward,
    
    ```import``` is used for getting functionality from another file or several functionalities or values while
    
    ```export``` is used for exposing functionality from a file or several functionalities or values.
    
    Exporting functionalites in a File or Named Exports
    
    Using ES5 (CommonJS)
    
        // Using ES5 CommonJS - helpers.js
        exports.isNull = function (val) {
          return val === null;
        }
        
        exports.isUndefined = function (val) {
          return val === undefined;
        }
        
        exports.isNullOrUndefined = function (val) {
          return exports.isNull(val) || exports.isUndefined(val);
        }
        
    Using ES6 Modules
    
        // Using ES6 Modules - helpers.js
        export function isNull(val){
          return val === null;
        }
        
        export function isUndefined(val) {
          return val === undefined;
        }
        
        export function isNullOrUndefined(val) {
          return isNull(val) || isUndefined(val);
        }
        
    Importing functionalites in another File
    
        // Using ES5 (CommonJS) - index.js
        const helpers = require('./helpers.js'); // helpers is an object
        const isNull = helpers.isNull;
        const isUndefined = helpers.isUndefined;
        const isNullOrUndefined = helpers.isNullOrUndefined;
        
        // or if your environment supports Destructuring
        const { isNull, isUndefined, isNullOrUndefined } = require('./helpers.js');
        
        // ES6 Modules - index.js
        import * as helpers from './helpers.js'; // helpers is an object
        
        // or 
        
        import { isNull, isUndefined, isNullOrUndefined as isValid } from './helpers.js';
        
        // using "as" for renaming named exports
        
    Exporting a Single Functionality in a File or Default Exports
    
        // Using ES5 (CommonJS) - index.js
        class Helpers {
          static isNull(val) {
            return val === null;
          }
        
          static isUndefined(val) {
            return val === undefined;
          }
        
          static isNullOrUndefined(val) {
            return this.isNull(val) || this.isUndefined(val);
          }
        }
        
        
        module.exports = Helpers;
        
    Using ES6 Modules
    
        // Using ES6 Modules - helpers.js
        class Helpers {
          static isNull(val) {
            return val === null;
          }
        
          static isUndefined(val) {
            return val === undefined;
          }
        
          static isNullOrUndefined(val) {
            return this.isNull(val) || this.isUndefined(val);
          }
        }
        
        export default Helpers
        
    Importing a Single Functionality from another File
    
    Using ES5 (CommonJS)
        
        // Using ES5 (CommonJS) - index.js
        const Helpers = require('./helpers.js'); 
        console.log(Helpers.isNull(null));
        
    Using ES6 Modules
    
        import Helpers from '.helpers.js'
        console.log(Helpers.isNull(null));
    
52. <a id="js-set-object">What is the Set object and how does it work?</a>

    The Set object is an ES6 feature that lets you store unique values, primitives or object references. A value in a Set can only occur once. It checks if a value exists in the set object using the SameValueZero algorithm.
    
    We can make ```Set``` instance using ```Set``` constructor and we can optionally pass an ```Iterable``` as the initial value.
    
        const set1 = new Set();
        const set2 = new Set(["a","b","c","d","d","e"]);
    
    We can add a new value into the Set instance using the add method and since the add returns the Set object we can chain add calls. If a value already exists in Set object it will not be added again.
            
        set2.add("f");
        set2.add("g").add("h").add("i").add("j").add("k").add("k");
        // the last "k" will not be added to the set object because it already exists
        
    We can remove a value from the Set instance using the delete method, this method returns a boolean indicating true if a value exists in the Set object and false indicating that value does not exist.
    
        set2.delete("k") // returns true because "k" exists in the set object
        set2.delete("z") // returns false because "z" does not exists in the set object
    
    We can check if a specific value exists in the Set instance using the has method.
    
        set2.has("a") // returns true because "a" exists in the set object
        set2.has("z") // returns false because "z" does not exists in the set object
        
    We can get the length of the Set instance using the size property.
    
        set2.size // returns 10
        
    We can delete or remove all the elements in the Set instance using the clear.
    
        set2.clear(); // clears the set data
        
    We can use the Set object for removing duplicate elements in an array.
    
        const numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];
        const uniqueNums = [...new Set(numbers)]; // has a value of [1,2,3,4,5,6,7,8]
    
53. <a id="js-callback">What is a Callback function?</a>

    A Callback function is a function that is gonna get called at a later point in time.
    
        const btnAdd = document.getElementById('btnAdd');
        
        btnAdd.addEventListener('click', function clickCallback(e) {
            // do something useless
        });
        
    In this example, we wait for the click event in the element with an id of btnAdd, if it is clicked, the clickCallback function is executed. A Callback function adds some functionality to some data or event. The reduce, filter and map methods in Array expects a callback as a parameter. A good analogy for a callback is when you call someone and if they don't answer you leave a message and you expect them to callback. The act of calling someone or leaving a message is the event or data and the callback is the action that you expect to occur later.

54. <a id="js-promises">What are Promises?</a>

    Promises are one way in handling asynchronous operations in JavaScript. It represents the value of an asynchronous operation. Promises was made to solve the problem of doing and dealing with async code before promises we're using callbacks.
    
        fs.readFile('somefile.txt', function (e, data) {
          if (e) {
            console.log(e);
          }
          console.log(data);
        });
        
    The problem with this approach if we have another async operation inside the callback and another. We will have a code that is messy and unreadable. This code is called Callback Hell.
    
        //Callback Hell yucksss
        fs.readFile('somefile.txt', function (e, data) {
          //your code here
          fs.readdir('directory', function (e, files) {
            //your code here
            fs.mkdir('directory', function (e) {
              //your code here
            })
          })
        })
        
    If we use promises in this code it will be more readable and easy to understand and easy to maintain.
    
        promReadFile('file/path')
          .then(data => {
            return promReaddir('directory');
          })
          .then(data => {
            return promMkdir('directory');
          })
          .catch(e => {
            console.log(e);
          })
          
    Promises have 3 different states.
    
    * ```Pending``` - The initial state of a promise. The promise's outcome has not yet been known because the operation has not been completed yet.
    * ```Fulfilled``` - The async operation is completed and successful with the resulting value.
    * ```Rejected``` - The async operation has failed and has a reason on why it failed.
    * ```Settled``` - If the promise has been either Fulfilled or Rejected.
    
    The Promise constructor has two parameters which are functions resolve and reject respectively.
    If the async operation has been completed without errors call the resolve function to resolve the promise or if an error occurred
    call the reject function and pass the error or reason to it.
    We can access the result of the fulfilled promise using the .then
    method and we catch errors in the .catch method. We chain multiple async promise operations in the .then method because the .then method returns a Promise just like the example in the imag e above.
    
        const myPromiseAsync = (...args) => {
          return new Promise((resolve, reject) => {
            doSomeAsync(...args, (error, data) => {
              if (error) {
                reject(error);
              } else {
                resolve(data);
              }
            })
          })
        }
        
        myPromiseAsync()
          .then(result => {
            console.log(result);
          })
          .catch(reason => {
            console.log(reason);
          })
          
    We can make a helper func that converts an async operation with a callback to promise. It works like the promisify utility function from the node core module util.
    
        const toPromise = (asyncFuncWithCallback) => {
          return (...args) => {
            return new Promise((res, rej) => {
              asyncFuncWithCallback(...args, (e, result) => {
                return e ? rej(e) : res(result);
              });
            });
          }
        }
        
        const promReadFile = toPromise(fs.readFile);
        
        promReadFile('file/path')
          .then((data) => {
            console.log(data);
          })
          .catch(e => console.log(e));
    
55. <a id="js-async-await">What is async/await and How does it work?</a>

    async/await is the new way of writing asynchronous or non-blocking code in JavaScript's. It is built on top of Promises. It makes writing asynchronous code more readable and cleaner than
    Promises and Callbacks. But you must learn the basics of Promises before using this feature because as I said earlier it is built on top of Promises which means is still uses Promises under the hood.
    
    Using Promises.
    
        function callApi() {
          return fetch("url/to/api/endpoint")
            .then(resp => resp.json())
            .then(data => {
              //do something with "data"
            }).catch(err => {
              //do something with "err"
            });
        }
        
    Using Async/Await.
    
    Note: We're using the old try/catch statement to catch any errors that happened in any of those async operations inside the try statement.
        
        async function callApi() {
          try {
            const resp = await fetch("url/to/api/endpoint");
            const data = await resp.json();
            //do something with "data"
          } catch (e) {
            //do something with "err"
          }
        }
        
    Note: The async keyword before the function declaration makes the function return implicitly a Promise.
    
        const giveMeOne = async () => 1;
        
        giveMeOne()
          .then((num) => {
            console.log(num); // logs 1
          });
          
    Note: The await keyword can only be used inside an async function. Using await keyword in any other function which is not an async function will throw an error. The await keyword awaits the right-hand side expression (presumably a Promise) to return before executing the next line of code.
    
        const giveMeOne = async () => 1;
        
        function getOne() {
          try {
            const num = await giveMeOne();
            console.log(num);
          } catch (e) {
            console.log(e);
          }
        }
        
        //Throws a Compile-Time Error = Uncaught SyntaxError: await is only valid in an async function
        
        async function getTwo() {
          try {
            const num1 = await giveMeOne(); //finishes this async operation first before going to
            const num2 = await giveMeOne(); //this line
            return num1 + num2;
          } catch (e) {
            console.log(e);
          }
        }
        
        await getTwo(); // returns 2 

56. <a id="js-spred-rest">What's the difference between Spread operator and Rest operator?</a>

    The Spread operator and Rest paremeters have the same operator ... the difference between is that the Spread operator we give or spread individual data of an array to another data while the Rest parameters is used in a function or an array to get all the arguments or values and put them in an array or extract some pieces of them.
    
        function add(a, b) {
          return a + b;
        };
        
        const nums = [5, 6];
        const sum = add(...nums);
        console.log(sum);
        
    In this example, we're using the Spread Operator when we call the add function we are spreading the nums array. So the value of parameter a will be 5 and the value of b will be 6. So the sum will be 11.
    
        function add(...rest) {
          return rest.reduce((total,current) => total + current);
        };
        
        console.log(add(1, 2)); // logs 3
        console.log(add(1, 2, 3, 4, 5)); // logs 15
        
    In this example, we have a function add that accepts any number of arguments and adds them all and return the total.
    
        const [first, ...others] = [1, 2, 3, 4, 5];
        console.log(first); //logs 1
        console.log(others); //logs [2,3,4,5]
        
    In this another example, we are using the Rest operator to extract all the remaining array values and put them in array others except the first item.

57. <a id="js-default-parameters">What are Default Parameters?</a>

    Default Parameters is a new way of defining default variables in JavaScript it is available in the ES6 or ECMAScript 2015 Version.
    
        //ES5 Version
        function add(a,b){
          a = a || 0;
          b = b || 0;
          return a + b;
        }
        
        //ES6 Version
        function add(a = 0, b = 0){
          return a + b;
        }
        //If we don't pass any argument for 'a' or 'b' then 
        // it's gonna use the "default parameter" value which is 0
        add(1); // returns 1 
        
    We can also use Destructuring in Default Paremeters.
    
        function getFirst([first, ...rest] = [0, 1]) {
          return first;
        }
        
        getFirst();  // returns 0
        getFirst([10,20,30]);  // returns 10
        
        function getArr({ nums } = { nums: [1, 2, 3, 4] }){
            return nums;
        }
        
        getArr(); // returns [1, 2, 3, 4]
        getArr({nums:[5,4,3,2,1]}); // returns [5,4,3,2,1]
        
    We can also use the parameters defined first to the parameters defined after them.
    
        function doSomethingWithValue(value = "Hello World", callback = () => { console.log(value) }) {
          callback();
        }
        doSomethingWithValue(); //logs "Hello World"

58. <a id="js-wrapper-objects">What are Wrapper Objects?</a>

    Primitive Values like ```string```,```number``` and ```boolean``` with the exception of ```null``` and ```undefined``` have properties and methods even though they are not ```objects```.
    
        let name = "marko";
        
        console.log(typeof name); // logs  "string"
        console.log(name.toUpperCase()); // logs  "MARKO"
        
    ```name``` is a ```primitive string``` value that has no properties and methods but in this example we are calling a ```toUpperCase()``` method which does not throw an error but returns MARKO.
    
    The reason for this is that the primitive value is temporarily converted or coerce to an ```object``` so the name variable behaves like an ```object```. Every primitive except ```null``` and ```undefined``` have ```Wrapper Objects```. The ```Wrapper Objects``` are ```String```,```Number```,```Boolean```,```Symbol``` and ```BigInt```. In this case, the ```name.toUpperCase()``` invocation, behind the scenes it looks like this.
    
        console.log(new String(name).toUpperCase()); // logs  "MARKO"
        
    The newly created object is immediately discarded after we finished accessing a property or calling a method.
    
59. <a id="js-diff-impl-expl">What is the difference between Implicit and Explicit Coercion?</a>

    Implicit Coercion is a way of converting values to another type without us programmer doing it directly or by hand.
     
    Suppose we have an example below.
    
        console.log(1 + '6');
        console.log(false + true);
        console.log(6 * '2');
        
    The first ```console.log``` statement logs ```16```. In other languages this would throw a compile time ```error``` but in JavaScript the ```1``` is converted to a ```string``` then concatenated with the ```+``` operator. We did not do anything, yet it was converted automatically by JavaScript for us.
    
    The second console.log statement logs 1, it converts the false to a boolean which will result to a 0 and the true will be 1 hence the result is 1.
    
    The third console.log statement logs 12, it converts the '2' to a number before multiplying 6 * 2 hence the result 12.

    While Explicit Coercion is the way of converting values to another type where we (programmers) explicitly do it.
    
        console.log(1 + parseInt('6'));
        
    In this example, we use the ```parseInt``` function to convert the ```6``` to a ```number``` then adding the ```1``` and ```6``` using the ```+``` operator.
    
60. <a id="js-check-is-array">How to check if a value is an Array?</a>

    We can check if a value is an Array by using the Array.isArray method available from the Array global object. It returns true when the parameter pass to it is an Array otherwise false.
    
        console.log(Array.isArray(5));  //logs false
        console.log(Array.isArray("")); //logs false
        console.log(Array.isArray()); //logs false
        console.log(Array.isArray(null)); //logs false
        console.log(Array.isArray({ length: 5 })); //logs false
        
        console.log(Array.isArray([])); //logs true
        
    If your environment does not support this method you can use the polyfill implementation.
    
         function isArray(value){
             return Object.prototype.toString.call(value) === "[object Array]"
          }
          
61. <a id="js-check-property-exist">How to check if a certain property exists in an object?</a>

    There are three possible ways to check if a property exists in an object.
    
    * First , using the ```in``` operator. The syntax for using the in operator is like this ```propertyname in object```. It returns ```true``` if the property exists otherwise it returns ```false```.
    
            const o = { 
              "prop" : "bwahahah",
              "prop2" : "hweasa"
            };
            
            console.log("prop" in o); //This logs true indicating the property "prop" is in "o" object
            console.log("prop1" in o); //This logs false indicating the property "prop" is not in  "o" object
            
    Second, using the hasOwnProperty method in objects. This method is available on all objects in JavaScript. It returns true if the property exists otherwise it returns false.
    
        //Still using the o object in the first example.
        console.log(o.hasOwnProperty("prop2")); // This logs true
        console.log(o.hasOwnProperty("prop1")); // This logs false
        
    Third, using the bracket notation ```obj["prop"]```. If the property exists it returns the value of that property otherwise this will return ```undefined```.
    
        //Still using the o object in the first example.
        console.log(o["prop"]); // This logs "bwahahah"
        console.log(o["prop1"]); // This logs undefined
    
63. <a id="js-ajax">What is AJAX?</a>

    AJAX stands for Asynchronous JavaScript and XML. It is a group of related technologies used to display data asynchronously. What this means is that we can send data to the server and get data from the server without reloading the web page.
    
    Technologies use for AJAX.
    
    * HTML - web page structure
    * CSS - the styling for the webpage
    * JavaScript - the behaviour of the webpage and updates to the DOM
    * XMLHttpRequest API - used to send and retrieve data from the server
    * PHP,Python,Nodejs - Some Server-Side language
    
64. <a id="js-create-object">What are the ways of making objects in JavaScript?</a>

    * Using Object Literal.
    
          const o = {
           name: "Mark",
           greeting() {
              return `Hi, I'm ${this.name}`;
           }
          };
        
          o.greeting(); //returns "Hi, I'm Mark"
          
    * Using Constructor Functions.
    
        function Person(name) {
           this.name = name;
        }
        
        Person.prototype.greeting = function () {
           return `Hi, I'm ${this.name}`;
        }
        
        const mark = new Person("Mark");
        
        mark.greeting(); //returns "Hi, I'm Mark"
        
    * Using Object.create method.
    
        const n = {
           greeting() {
              return `Hi, I'm ${this.name}`;
           }
        };
        
        const o = Object.create(n); // sets the prototype of "o" to be "n"
        
        o.name = "Mark";
        
        console.log(o.greeting()); // logs "Hi, I'm Mark"

65. <a id="js-diff-freeze-seal">What's the difference between Object.seal and Object.freeze methods?</a>

    The difference between these two methods is that when we use the Object.freeze method to an object, that object's properties are immutable meaning we can't change or edit the values of those properties. While in the Object.seal method we can change those existing properties.

66. <a id="js-diff-in-hasOwnProperty">What's the difference between the in operator and the hasOwnProperty method in objects?</a>

    As you know both of these features check if a property exists in an object. It will return truefalse. The difference between them is that the in operator also checks the objects' Prototype Chain if the property was not found in the current object while the hasOwnProperty method just checks if the property exists in the current object ignoring the Prototype Chain.
    
        // We'll still use the object in the previous question.
        console.log("prop" in o); // This logs true;
        console.log("toString" in o); // This logs true, the toString method is available in this object's prototype which is the Object.prototype
        
        
        console.log(o.hasOwnProperty("prop")); // This logs true
        console.log(o.hasOwnProperty("toString")); // This logs false, does not check the object's prototype
    
67. <a id="js-asynch">What are the ways to deal with Asynchronous Code in JavasScript?</a>

    * Callbacks
    * Promises
    * async-await
    * Libraries like async.js, bluebird, q, co

68. <a id="js-expr-decl">What's the difference between a function expression and function declaration?</a>

    Suppose we have an example below.
    
        hoistedFunc();
        notHoistedFunc();
        
        function hoistedFunc(){
          console.log("I am hoisted");
        }
        
        var notHoistedFunc = function(){
          console.log("I will not be hoisted!");
        }
        
    The notHoistedFunc call throws an error while the hoistedFunc call does not because the hoistedFunc is hoisted while the notHoistedFunc is not.

69. <a id="js-ways-invoke-func">How many ways can a function be invoked?</a>

    There are 4 ways that a function can be invoked in JavaScript. The invocation determines the value of this or the "owner" object of that function.
    
    * ```Invocation as a function``` - If a function isn't invoked as a method, as a constructor or with the apply, call methods then it is invoked as a function. The "owner" object of this function will be the window object.
        
          //Global Scope
        
          function add(a,b){
            console.log(this);
            return a + b;
          }  
        
          add(1,5); // logs the "window" object and returns 6
        
          const o = {
            method(callback){
              callback();
            }
          }
        
          o.method(function (){
              console.log(this); // logs the "window" object
          });
          
    * ```Invocation as a method``` - If a property of an object has a value of a function we call it a method. When that method is invoked the this value of that method will be that object.
    
           const details = {
             name : "Marko",
             getName(){
               return this.name;
             }
           }
        
           details.getName(); // returns Marko
           // the "this" value inside "getName" method will be the "details" object
           
    * ```Invocation as a constructor``` - If a function was invoked with a new keyword before it then it's called a function constructor. An empty object will be created and ```this``` will point to that object.
    
            function Employee(name, position, yearHired) {
              // creates an empty object {}
              // then assigns the empty object to the "this" keyword
              // this = {};
              this.name = name;
              this.position = position;
              this.yearHired = yearHired;
              // inherits from Employee.prototype
              // returns the "this" value implicitly if no 
              // explicit return statement is specified
            };
            
            const emp = new Employee("Marko Polo", "Software Developer", 2017);
            
    * ```Invocation with the apply and call methods``` - If we want to explicitly specify the ```this``` value or the "owner" object of a function we can use these methods. These methods are available for all functions.
    
            const obj1 = {
             result:0
            };
            
            const obj2 = {
             result:0
            };
            
            
            function reduceAdd(){
               let result = 0;
               for(let i = 0, len = arguments.length; i < len; i++){
                 result += arguments[i];
               }
               this.result = result;
            }
            
            
            reduceAdd.apply(obj1, [1, 2, 3, 4, 5]);  //the "this" object inside the "reduceAdd" function will be "obj1"
            reduceAdd.call(obj2, 1, 2, 3, 4, 5); //the "this" object inside the "reduceAdd" function will be "obj2"
    
70. <a id="js-memoization">What is memoization and what's the use it?</a>

    memoization is a process of building a function that is capable of remembering it's previously computed results or values.
    
    The use of making a memoization function is that we avoid the computation of that function if it was already performed in the last calculations with the same arguments. This saves time but has a downside that we will consume more memory for saving the previous results.

71. <a id="js-impl-memoization">Implement a memoization helper function.</a>

        function memoize(fn) {
          const cache = {};
          return function (param) {
            if (cache[param]) {
              console.log('cached');
              return cache[param];
            } else {
              let result = fn(param);
              cache[param] = result;
              console.log(`not cached`);
              return result;
            }
          }
        }
        
        const toUpper = (str ="")=> str.toUpperCase();
        
        const toUpperMemoized = memoize(toUpper);
        
        toUpperMemoized("abcdef");
        toUpperMemoized("abcdef");
        
    This memoize helper function only works on a function that accepts one argument. We need to make a memoize helper function that accepts multiple arguments.
    
        const slice = Array.prototype.slice;
        function memoize(fn) {
          const cache = {};
          return (...args) => {
            const params = slice.call(args);
            console.log(params);
            if (cache[params]) {
              console.log('cached');
              return cache[params];
            } else {
              let result = fn(...args);
              cache[params] = result;
              console.log(`not cached`);
              return result;
            }
          }
        }
        const makeFullName = (fName, lName) => `${fName} ${lName}`;
        const reduceAdd = (numbers, startingValue = 0) => numbers.reduce((total, cur) => total + cur, startingValue);
        
        const memoizedMakeFullName = memoize(makeFullName);
        const memoizedReduceAdd = memoize(reduceAdd);
        
        memoizedMakeFullName("Marko", "Polo");
        memoizedMakeFullName("Marko", "Polo");
        
        memoizedReduceAdd([1, 2, 3, 4, 5], 5);
        memoizedReduceAdd([1, 2, 3, 4, 5], 5);

72. <a id="js-null-obj">Why does typeof null return object? How to check if a value is null?</a>

    ```typeof null == 'object'``` will always return ```true``` because this was the implementation of ```null``` since the birth of JavaScript. A fix was proposed to change ```typeof null == 'object'``` to typeof ```null == 'null'``` but was rejected because it will lead to more bugs.
    
    We can use the ```===``` or ```strict equality operator``` to check if a value is ```null```.
    
73. <a id="js-new">What does the new keyword do?</a>

    The new keyword is used with constructor functions to make objects
    in JavaScript.
    
    Suppose we have an example code below.
    
        function Employee(name, position, yearHired) {
          this.name = name;
          this.position = position;
          this.yearHired = yearHired;
        };
        
        const emp = new Employee("Marko Polo", "Software Developer", 2017);
        
    The ```new``` keyword does 4 things.
    
    * Creates an empty object.
    * Assigns that empty object to the ``this`` value.
    * The function will inherit from ```functionName.prototype```.
    * Returns the ```this``` if no Explicit return statement is used.
    
    In the above image, it will first create an empty object {} then
    it will the ```this``` value to that empty object ```this = {}``` and add properties to that this object. Because we don't have a explicit return statement it automatically returns the this for us.

### Javascript tasks

1. <a id="js-task-1">What is a potential pitfall with using ```typeof bar === "object"``` to determine if bar is an object? How can this pitfall be avoided?</a>

    Although ```typeof bar === "object"``` is a reliable way of checking if bar is an ```object```, the surprising gotcha in JavaScript is that null is also considered an ```object```!
        
    Therefore, the following code will, to the surprise of most developers, log ```true``` (not ```false```) to the console:
        
        var bar = null;
        console.log(typeof bar === "object");  // logs true!
            
    As long as one is aware of this, the problem can easily be avoided by also checking if ```bar``` is ```null```:
        
        console.log((bar !== null) && (typeof bar === "object"));  // logs false
        
2. <a id="js-task-2">What will the code below output to the console and why?</a>

    (function(){
              var a = b = 3;
            })();
            
            console.log("a defined? " + (typeof a !== 'undefined'));
            console.log("b defined? " + (typeof b !== 'undefined'));
            
    ---

    As a result (if you are not using strict mode), the output of the code snippet would be:
    
        a defined? false
        b defined? true
        
    But how can ```b``` be defined outside of the scope of the enclosing function? Well, since the statement ```var a = b = 3;``` is shorthand for the statements ```b = 3;``` and ```var a = b;```, ```b``` ends up being a global variable (since it is not preceded by the var keyword) and is therefore still in scope even outside of the enclosing function.
    
3. <a id="js-task-3">What will the code below output to the console and why?</a>

        var myObject = {
                    foo: "bar",
                    func: function() {
                        var self = this;
                        console.log("outer func:  this.foo = " + this.foo);
                        console.log("outer func:  self.foo = " + self.foo);
                        (function() {
                            console.log("inner func:  this.foo = " + this.foo);
                            console.log("inner func:  self.foo = " + self.foo);
                        }());
                    }
                };
        myObject.func();
                
    ---

    The above code will output the following to the console:
    
        outer func:  this.foo = bar
        outer func:  self.foo = bar
        inner func:  this.foo = undefined
        inner func:  self.foo = bar
        
    In the outer function, both ```this``` and ```self``` refer to ```myObject``` and therefore both can properly reference and access ```foo```.
    
    In the ```inner``` function, though, this no longer refers to ```myObject```. As a result, ```this.foo``` is ```undefined``` in the inner function, whereas the reference to the local variable ```self``` remains in scope and is accessible there.
    
4. <a id="js-task-4">Consider the two functions below. Will they both return the same thing? Why or why not?</a>

        function foo1()
        {
          return {
              bar: "hello"
          };
        }
        
        function foo2()
        {
          return
          {
              bar: "hello"
          };
        }
        
    ---
    
    Surprisingly, these two functions will not return the same thing. Rather:
    
        console.log("foo1 returns:");
        console.log(foo1());
        console.log("foo2 returns:");
        console.log(foo2());
        
    will yield:
    
        foo1 returns:
        Object {bar: "hello"}
        foo2 returns:
        undefined 
        
    The reason for this has to do with the fact that semicolons are technically optional in JavaScript (although omitting them is generally really bad form). As a result, when the line containing the ```return``` statement (with nothing else on the line) is encountered in ```foo2()```, a semicolon is automatically inserted immediately after the return statement.

5. <a id="js-task-5">What will the code below output? Explain your answer.</a>

        console.log(0.1 + 0.2);
        console.log(0.1 + 0.2 == 0.3);
    
    ---
    
    An educated answer to this question would simply be: “You can’t be sure. it might print out ```0.3``` and ```true```, or it might not. Numbers in JavaScript are all treated with floating point precision, and as such, may not always yield the expected results.”
    
    The example provided above is classic case that demonstrates this issue. Surprisingly, it will print out:
    
        0.30000000000000004
        false
    
6. <a id="js-task-6">Discuss possible ways to write a function isInteger(x) that determines if x is an integer.</a>

    This may sound trivial and, in fact, it is trivial with ECMAscript 6 which introduces a new ```Number.isInteger()``` function for precisely this purpose. However, prior to ECMAScript 6, this is a bit more complicated, since no equivalent of the ```Number.isInteger()``` method is provided.
    
    With that in mind, the simplest and cleanest pre-ECMAScript-6 solution (which is also sufficiently robust to return ```false``` even if a non-numeric value such as a ```string``` or ```null``` is passed to the function) would be the following use of the bitwise XOR operator:
    
        function isInteger(x) { return (x ^ 0) === x; } 
        
    The following solution would also work, although not as elegant as the one above:
    
        function isInteger(x) { return Math.round(x) === x; }
    
7. <a id="js-task-7">In what order will the numbers 1-4 be logged to the console when the code below is executed? Why?</a>

        (function() {
            console.log(1); 
            setTimeout(function(){console.log(2)}, 1000); 
            setTimeout(function(){console.log(3)}, 0); 
            console.log(4);
        })();
            
    ---
    
    The values will be logged in the following order:
    
        1
        4
        3
        2
        
    Let’s first explain the parts of this that are presumably more obvious:
    
    * ```1``` and ```4``` are displayed first since they are logged by simple calls to ```console.log()``` without any delay
    * ```2``` is displayed after ```3``` because ```2``` is being logged after a delay of 1000 msecs (i.e., 1 second) whereas ```3``` is being logged after a delay of 0 msecs.

    The browser has an event loop which checks the event queue and processes pending events. For example, if an event happens in the background (e.g., a script ```onload``` event) while the browser is busy (e.g., processing an ```onclick```), the event gets appended to the queue. When the onclick handler is complete, the queue is checked and the event is then handled (e.g., the ```onload``` script is executed).
    
8. <a id="js-task-8">Write a simple function (less than 160 characters) that returns a boolean indicating whether or not a string is a palindrome.</a>

        function isPalindrome(string) {
            return string.toLowerCase() === string.toLowerCase().split("").reverse().join("");
        }
        
        console.log(isPalindrome("level"));                   // logs 'true'
        console.log(isPalindrome("levels"));                  // logs 'false'
    
9. <a id="js-task-9">Write a sum method which will work properly when invoked using either syntax below.</a>

        function sum(...arr) {
        	const result = arr.reduce((acc, item) => {
          	return acc + item;
          }, Number(sum) || 0);
          
          sum.toString = function () {
          	return result;
          }
          
          return sum;
        }

10. <a id="js-task-10">Consider the following code snippet:</a>

        for (var i = 0; i < 5; i++) {
          var btn = document.createElement('button');
          btn.appendChild(document.createTextNode('Button ' + i));
          btn.addEventListener('click', function(){ console.log(i); });
          document.body.appendChild(btn);
        }
                
    * What gets logged to the console when the user clicks on “Button 4” and why?
            
    No matter what button the user clicks the number ```5``` will always be logged to the console. This is because, at the point that the ```onclick``` method is invoked (for any of the buttons), the ```for``` loop has already completed and the variable ```i``` already has a value of ```5```.
        
    * Provide one or more alternate implementations that will work as expected.
    
    The key to making this work is to capture the value of ```i``` at each pass through the ```for``` loop by passing it into a newly created function object. Here are four possible ways to accomplish this:
    
        for (var i = 0; i < 5; i++) {
          var btn = document.createElement('button');
          btn.appendChild(document.createTextNode('Button ' + i));
          btn.addEventListener('click', (function(i) {
            return function() { console.log(i); };
          })(i));
          document.body.appendChild(btn);
        }
        
    ---
    
        for (var i = 0; i < 5; i++) {
          var btn = document.createElement('button');
          btn.appendChild(document.createTextNode('Button ' + i));
          (function (i) {
            btn.addEventListener('click', function() { console.log(i); });
          })(i);
          document.body.appendChild(btn);
        }
        
    ---
    
        ['a', 'b', 'c', 'd', 'e'].forEach(function (value, i) {
          var btn = document.createElement('button');
          btn.appendChild(document.createTextNode('Button ' + i));
          btn.addEventListener('click', function() { console.log(i); });
          document.body.appendChild(btn);
        });
        
    ---
    
        for (let i = 0; i < 5; i++) {
          var btn = document.createElement('button');
          btn.appendChild(document.createTextNode('Button ' + i));
          btn.addEventListener('click', function(){ console.log(i); });
          document.body.appendChild(btn);
        }
        
11. <a id="js-task-11">Assuming d is an “empty” object in scope, say:</a>

    …what is accomplished using the following code?
    
    The snippet of code shown above sets two properties on the object ```d```. Ideally, any lookup performed on a JavaScript object with an unset key evaluates to ```undefined```. But running this code marks those properties as ```“own properties”``` of the object.
    
    This is a useful strategy for ensuring that an object has a given set of properties. Passing this object to ```Object.keys``` will return an array with those set keys as well (even if their values are ```undefined```).
    
12. <a id="js-task-12">What will the code below output to the console and why?</a>

    var arr1 = "john".split('');
    var arr2 = arr1.reverse();
    var arr3 = "jones".split('');
    arr2.push(arr3);
    console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));
    console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1));
    
    ---
    
    The logged output will be:
    
        "array 1: length=5 last=j,o,n,e,s"
        "array 2: length=5 last=j,o,n,e,s"
        
    arr1 and arr2 are the same (i.e. ```['n','h','o','j', ['j','o','n','e','s'] ]```) after the above code is executed for the following reasons:
    
    * Calling an array object’s ```reverse()``` method doesn’t only return the array in reverse order, it also reverses the order of the array itself (i.e., in this case, arr1).
    * The ```reverse()``` method returns a reference to the array itself (i.e., in this case, ```arr1```). As a result, ```arr2``` is simply a reference to (rather than a copy of) ```arr1```. Therefore, when anything is done to ```arr2``` (i.e., when we invoke ```arr2.push(arr3);```), ```arr1``` will be affected as well since ```arr1``` and ```arr2``` are simply references to the same object.
    
13. <a id="js-task-13">What will the code below output to the console and why ?</a>

        console.log(1 +  "2" + "2");
        console.log(1 +  +"2" + "2");
        console.log(1 +  -"1" + "2");
        console.log(+"1" +  "1" + "2");
        console.log( "A" - "B" + "2");
        console.log( "A" - "B" + 2);
        
    ---
    
        "122"
        "32"
        "02"
        "112"
        "NaN2"
        NaN

14. <a id="js-task-14">The following recursive code will cause a stack overflow if the array list is too large. How can you fix this and still retain the recursive pattern?</a>

        var list = readHugeList();
        
        var nextListItem = function() {
            var item = list.pop();
        
            if (item) {
                // process the list item...
                nextListItem();
            }
        };
        
    ---
    
    The potential stack overflow can be avoided by modifying the nextListItem function as follows:
    
        var list = readHugeList();
        
        var nextListItem = function() {
            var item = list.pop();
        
            if (item) {
                // process the list item...
                setTimeout( nextListItem, 0);
            }
        };
        
    The stack overflow is eliminated because the event loop handles the recursion, not the call stack. When nextListItem runs, if ```item``` is not ```null```, the timeout function (```nextListItem```) is pushed to the event queue and the function exits, thereby leaving the call stack clear. When the event queue runs its timed-out event, the next ```item``` is processed and a timer is set to again invoke ```nextListItem```. Accordingly, the method is processed from start to finish without a direct recursive call, so the call stack remains clear, regardless of the number of iterations.

15. <a id="js-task-15">What will be the output of the following code:</a>

        for (var i = 0; i < 5; i++) {
            setTimeout(function() { console.log(i); }, i * 1000 );
        }
        
    ---

    The code sample shown will not display the values 0, 1, 2, 3, and 4 as might be expected; rather, it will display 5, 5, 5, 5, and 5.
    
    The reason for this is that each function executed within the loop will be executed after the entire loop has completed and all will therefore reference the last value stored in ```i```, which was ```5```.
    
    Closures can be used to prevent this problem by creating a unique scope for each iteration, storing each unique value of the variable within its scope, as follows:
    
        for (var i = 0; i < 5; i++) {
            (function(x) {
                setTimeout(function() { console.log(x); }, x * 1000 );
            })(i);
        }
        
    In an ES2015 context, you can simply use let instead of var in the original code:
    
        for (let i = 0; i < 5; i++) {
        	setTimeout(function() { console.log(i); }, i * 1000 );
        }
    
16. <a id="js-task-16">What would the following lines of code output to the console?</a>

        console.log("0 || 1 = "+(0 || 1));
        console.log("1 || 2 = "+(1 || 2));
        console.log("0 && 1 = "+(0 && 1));
        console.log("1 && 2 = "+(1 && 2));
        
    ---
    
    The code will output the following four lines:
    
        0 || 1 = 1
        1 || 2 = 1
        0 && 1 = 0
        1 && 2 = 2
        
    In JavaScript, both || and && are logical operators that return the first fully-determined “logical value” when evaluated from left to right.

17. <a id="js-task-17">What will be the output when the following code is executed? Explain.</a>

        console.log(false == '0')
        console.log(false === '0')
        
    ---
    
    The code will output:
    
        true
        false
        
    In JavaScript, there are two sets of equality operators. The triple-equal operator ```===``` behaves like any traditional equality operator would: evaluates to ```true``` if the two expressions on either of its sides have the same type and the same value. The double-equal operator, however, tries to coerce the values before comparing them. It is therefore generally good practice to use the ```===``` rather than ```==.``` The same holds true for ```!==``` vs ```!=```.

18. <a id="js-task-18">What is the output out of the following code? Explain your answer.</a>

        var a={},
            b={key:'b'},
            c={key:'c'};
        
        a[b]=123;
        a[c]=456;
        
        console.log(a[b]);
        
    ---
    
    The output of this code will be ```456``` (not ```123```).
    
    The reason for this is as follows: When setting an object property, JavaScript will implicitly stringify the parameter value. In this case, since ```b``` and ```c``` are both objects, they will both be converted to ```[object Object]```. As a result, ```a[b]``` and ```a[c]``` are both equivalent to ```a["[object Object]"]``` and can be used interchangeably. Therefore, setting or referencing ```a[c]``` is precisely the same as setting or referencing ```a[b]```.

19. <a id="js-task-19">What will the following code output to the console:</a>

        console.log((function f(n){return ((n > 1) ? n * f(n-1) : n)})(10));
            
    ---
    
    The code will output the value of 10 factorial (i.e., 10!, or 3,628,800).
    
    Here’s why:
    
    The named function ```f()``` calls itself recursively, until it gets down to calling ```f(1)``` which simply returns ```1```. Here, therefore, is what this does:
    
        f(1): returns n, which is 1
        f(2): returns 2 * f(1), which is 2
        f(3): returns 3 * f(2), which is 6
        f(4): returns 4 * f(3), which is 24
        f(5): returns 5 * f(4), which is 120
        f(6): returns 6 * f(5), which is 720
        f(7): returns 7 * f(6), which is 5040
        f(8): returns 8 * f(7), which is 40320
        f(9): returns 9 * f(8), which is 362880
        f(10): returns 10 * f(9), which is 3628800

20. <a id="js-task-20">Consider the code snippet below. What will the console output be and why?</a>

        (function(x) {
            return (function(y) {
                console.log(x);
            })(2)
        })(1);
        
    ---
    
    The output will be ```1```, even though the value of ```x``` is never set in the inner function. Here’s why:
    
    A closure is a function, along with all variables or functions that were in-scope at the time that the closure was created. In JavaScript, a closure is implemented as an “inner function”; i.e., a function defined within the body of another function. An important feature of closures is that an inner function still has access to the outer function’s variables.
    
    Therefore, in this example, since ```x``` is not defined in the inner function, the scope of the outer function is searched for a defined variable ```x```, which is found to have a value of ```1```.

21. <a id="js-task-21"></a>
22. <a id="js-task-22"></a>
23. <a id="js-task-23"></a>
24. <a id="js-task-24"></a>
25. <a id="js-task-25"></a>
26. <a id="js-task-26"></a>
27. <a id="js-task-27"></a>
28. <a id="js-task-28"></a>
